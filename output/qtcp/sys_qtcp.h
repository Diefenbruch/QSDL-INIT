/******************************************************************************
 *                            sys_qtcp.h
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef _SYS_QTCP_H_
#define _SYS_QTCP_H_

/******************************************************************************
 * Includes
 *****************************************************************************/

#include <SCL/SCSystem.h>
#include <SCL/SCDataType.h>
#include <SCL/SCSyntype.h>
#include <SCL/SCArray.h>
#include <SCL/SCString.h>
#include <SCL/SCSignalType.h>
#include <SCL/SCRequestType.h>
#include <SCL/SCCharstring.h>
#include <SCL/SCRandConst.h>
#include <SCL/SCRandEmpirical.h>
#include <SCL/SCRandErlang.h>
#include <SCL/SCRandNegExp.h>
#include <SCL/SCRandNormal.h>
#include <SCL/SCRandUniform.h>
#include <SCL/SCRandBernoulli.h>
#include <SCL/SCRandPoisson.h>
#include <SCL/SCRandUniLong.h>
#include <SCL/SCByte.h>
#include <SCL/SCMem.h>

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h> // fuer memset
#include <SCL/SCStream.h>

#define MAX_PATH 128

/******************************************************************************
 * SDL-Systemklasse
 *****************************************************************************/

class sys_qtcp : public SCSystem
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Systems (statisch)
     *************************************************************************/

    static SCBoolean Initialize(class SCIndet *, class SCSocket *,
                                SCBoolean, SCBoolean, SCBoolean,
                                SCBoolean, SCBoolean, const char *,
                                const char *, const SCNatural,
                                const char *, SCReal);

    /**************************************************************************
     * Beendigungsfunktion des Systems (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktor
     *************************************************************************/

    sys_qtcp(void);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~sys_qtcp(void);

    /**************************************************************************
     * Benutzerdefinierte SDL-Datentypen auf Systemebene
     *************************************************************************/

    static SCInteger syn_medium_buffer;
    static SCDuration syn_medium_delay;
    static SCDuration syn_mrtt;
    static SCDuration syn_default_to;
    static SCDuration syn_time_out;
    static SCInteger syn_maxnr;
    static SCInteger syn_window_size;
    static SCInteger syn_buffer_size;
    static SCInteger syn_max_retransmit;
    static SCDuration syn_connection_time;
    static SCDuration syn_wait_delay;
    static SCInteger syn_destroy_rate;
    static SCBoolean syn_fault;
    static SCInteger syn_standard;
    static SCInteger syn_max_connections;
    static SCInteger syn_num_of_connections;
    static SCInteger syn_server_a_address;
    static SCInteger syn_server_b_address;
    static SCInteger syn_standard_timeout;
    static SCInteger syn_standard_timeout_action;
    static SCInteger syn_standard_prec;
    static SCInteger syn_standard_security;
    static SCBoolean syn_no_ack_flag;
    static SCBoolean syn_no_push_flag;
    static SCBoolean syn_no_urgent_flag;
    static SCBoolean syn_no_fin_flag;
    static SCBoolean syn_no_syn_flag;
    static SCBoolean syn_no_reset_flag;
    static SCBoolean syn_ack_flag;
    static SCBoolean syn_push_flag;
    static SCBoolean syn_fin_flag;
    static SCBoolean syn_syn_flag;
    static SCBoolean syn_reset_flag;
    static SCInteger syn_fatal_error;
    static SCInteger syn_default_error;
    static SCDuration syn_load_generation_delay;
    /**************************************************************************
     * SDL-Syntype: 'iplength':
     *************************************************************************/

    struct DataType_iplength : public SCSyntype<SCInteger>
    {
      DataType_iplength(void) : SCSyntype<SCInteger> (0, 536,
                                                      0, NULL) {}
      DataType_iplength(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                536,
                                                                init,
                                                                NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_iplength& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'tcplength':
     *************************************************************************/

    struct DataType_tcplength : public SCSyntype<SCInteger>
    {
      DataType_tcplength(void) : SCSyntype<SCInteger> (0, syn_standard,
                                                       0, NULL) {}
      DataType_tcplength(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                 syn_standard,
                                                                 init,
                                                                 NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_tcplength& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'portrange':
     *************************************************************************/

    struct DataType_portrange : public SCSyntype<SCInteger>
    {
      DataType_portrange(void) : SCSyntype<SCInteger> (0, 256,
                                                       0, NULL) {}
      DataType_portrange(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                 256,
                                                                 init,
                                                                 NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_portrange& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'windowsize':
     *************************************************************************/

    struct DataType_windowsize : public SCSyntype<SCInteger>
    {
      DataType_windowsize(void) : SCSyntype<SCInteger> (0, syn_maxnr,
                                                        0, NULL) {}
      DataType_windowsize(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                  syn_maxnr,
                                                                  init,
                                                                  NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_windowsize& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'bufferrange':
     *************************************************************************/

    struct DataType_bufferrange : public SCSyntype<SCInteger>
    {
      DataType_bufferrange(void) : SCSyntype<SCInteger> (0, syn_medium_buffer,
                                                         0,
                                                         NULL) {}
      DataType_bufferrange(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                   syn_medium_buffer,
                                                                   init,
                                                                   NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_bufferrange& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'retransmitrange':
     *************************************************************************/

    struct DataType_retransmitrange : public SCSyntype<SCInteger>
    {
      DataType_retransmitrange(void) : SCSyntype<SCInteger> (0,
                                                             syn_buffer_size,
                                                             0,
                                                             NULL) {}
      DataType_retransmitrange(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                       syn_buffer_size,
                                                                       init,
                                                                       NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_retransmitrange& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Newtype: Struct 'tcp':
     *************************************************************************/

    struct DataType_tcp : public SCDataType
    {
      // Default Konstruktor:
      DataType_tcp(void)
      {
        field_sp = 0;
        field_dp = 0;
        field_sa = 0;
        field_da = 0;
        field_seq = 0;
        field_an = 0;
        field_wnd = 0;
        field_urgp = 0;
        field_syn = false;
        field_ack = false;
        field_rst = false;
        field_fin = false;
        field_urg = false;
        field_psh = false;
      }
      // Copy Konstruktor:
      DataType_tcp(const DataType_tcp& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_sp;
      SCInteger field_dp;
      SCInteger field_sa;
      SCInteger field_da;
      SCInteger field_seq;
      SCInteger field_an;
      SCInteger field_wnd;
      SCInteger field_urgp;
      DataType_tcplength field_len;
      DataType_tcplength field_cs;
      SCBoolean field_syn;
      SCBoolean field_ack;
      SCBoolean field_rst;
      SCBoolean field_fin;
      SCBoolean field_urg;
      SCBoolean field_psh;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_tcp(*this);
      }
      // Zuweisungsoperator:
      DataType_tcp& operator= (const DataType_tcp &orig)
      {
        field_sp = orig.field_sp;
        field_dp = orig.field_dp;
        field_sa = orig.field_sa;
        field_da = orig.field_da;
        field_seq = orig.field_seq;
        field_an = orig.field_an;
        field_wnd = orig.field_wnd;
        field_urgp = orig.field_urgp;
        field_len = orig.field_len;
        field_cs = orig.field_cs;
        field_syn = orig.field_syn;
        field_ack = orig.field_ack;
        field_rst = orig.field_rst;
        field_fin = orig.field_fin;
        field_urg = orig.field_urg;
        field_psh = orig.field_psh;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_tcp &second) const
      {
        return (field_sp == second.field_sp && field_dp == second.field_dp &&
                field_sa == second.field_sa && field_da == second.field_da &&
                field_seq == second.field_seq && field_an == second.field_an &&
                field_wnd == second.field_wnd && field_urgp == second.field_urgp &&
                field_len == second.field_len && field_cs == second.field_cs &&
                field_syn == second.field_syn && field_ack == second.field_ack &&
                field_rst == second.field_rst && field_fin == second.field_fin &&
                field_urg == second.field_urg && field_psh == second.field_psh);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_tcp *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_tcp &me)
      {
        out << "[";
        out << me.field_sp << ", ";
        out << me.field_dp << ", ";
        out << me.field_sa << ", ";
        out << me.field_da << ", ";
        out << me.field_seq << ", ";
        out << me.field_an << ", ";
        out << me.field_wnd << ", ";
        out << me.field_urgp << ", ";
        out << me.field_len << ", ";
        out << me.field_cs << ", ";
        out << me.field_syn << ", ";
        out << me.field_ack << ", ";
        out << me.field_rst << ", ";
        out << me.field_fin << ", ";
        out << me.field_urg << ", ";
        out << me.field_psh;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_sp, sizeof(SCInteger));
        save_area.Store(&field_dp, sizeof(SCInteger));
        save_area.Store(&field_sa, sizeof(SCInteger));
        save_area.Store(&field_da, sizeof(SCInteger));
        save_area.Store(&field_seq, sizeof(SCInteger));
        save_area.Store(&field_an, sizeof(SCInteger));
        save_area.Store(&field_wnd, sizeof(SCInteger));
        save_area.Store(&field_urgp, sizeof(SCInteger));
        field_len.Save(save_area);
        field_cs.Save(save_area);
        save_area.Store(&field_syn, sizeof(SCBoolean));
        save_area.Store(&field_ack, sizeof(SCBoolean));
        save_area.Store(&field_rst, sizeof(SCBoolean));
        save_area.Store(&field_fin, sizeof(SCBoolean));
        save_area.Store(&field_urg, sizeof(SCBoolean));
        save_area.Store(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_sp, sizeof(SCInteger));
        save_area.HistoryStore(&field_dp, sizeof(SCInteger));
        save_area.HistoryStore(&field_sa, sizeof(SCInteger));
        save_area.HistoryStore(&field_da, sizeof(SCInteger));
        save_area.HistoryStore(&field_seq, sizeof(SCInteger));
        save_area.HistoryStore(&field_an, sizeof(SCInteger));
        save_area.HistoryStore(&field_wnd, sizeof(SCInteger));
        save_area.HistoryStore(&field_urgp, sizeof(SCInteger));
        field_len.HistorySave(save_area);
        field_cs.HistorySave(save_area);
        save_area.HistoryStore(&field_syn, sizeof(SCBoolean));
        save_area.HistoryStore(&field_ack, sizeof(SCBoolean));
        save_area.HistoryStore(&field_rst, sizeof(SCBoolean));
        save_area.HistoryStore(&field_fin, sizeof(SCBoolean));
        save_area.HistoryStore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryStore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_sp, sizeof(SCInteger));
        save_area.Restore(&field_dp, sizeof(SCInteger));
        save_area.Restore(&field_sa, sizeof(SCInteger));
        save_area.Restore(&field_da, sizeof(SCInteger));
        save_area.Restore(&field_seq, sizeof(SCInteger));
        save_area.Restore(&field_an, sizeof(SCInteger));
        save_area.Restore(&field_wnd, sizeof(SCInteger));
        save_area.Restore(&field_urgp, sizeof(SCInteger));
        field_len.Restore(save_area);
        field_cs.Restore(save_area);
        save_area.Restore(&field_syn, sizeof(SCBoolean));
        save_area.Restore(&field_ack, sizeof(SCBoolean));
        save_area.Restore(&field_rst, sizeof(SCBoolean));
        save_area.Restore(&field_fin, sizeof(SCBoolean));
        save_area.Restore(&field_urg, sizeof(SCBoolean));
        save_area.Restore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_sp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_dp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_sa, sizeof(SCInteger));
        save_area.HistoryRestore(&field_da, sizeof(SCInteger));
        save_area.HistoryRestore(&field_seq, sizeof(SCInteger));
        save_area.HistoryRestore(&field_an, sizeof(SCInteger));
        save_area.HistoryRestore(&field_wnd, sizeof(SCInteger));
        save_area.HistoryRestore(&field_urgp, sizeof(SCInteger));
        field_len.HistoryRestore(save_area);
        field_cs.HistoryRestore(save_area);
        save_area.HistoryRestore(&field_syn, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_ack, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_rst, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_fin, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        field_len.Size(cur_size);
        field_cs.Size(cur_size);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        field_len.HistorySize(cur_size);
        field_cs.HistorySize(cur_size);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
      }
    };

    /**************************************************************************
     * SDL-Newtype: Struct 'ip':
     *************************************************************************/

    struct DataType_ip : public SCDataType
    {
      // Default Konstruktor:
      DataType_ip(void)
      {
        field_src = 0;
        field_dst = 0;
        field_prot = 0;
        field_tos = 0;
        field_ttl = 0;
        field_id = 0;
        field_options = 0;
        field_df = false;
      }
      // Copy Konstruktor:
      DataType_ip(const DataType_ip& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_src;
      SCInteger field_dst;
      SCInteger field_prot;
      SCInteger field_tos;
      SCInteger field_ttl;
      SCInteger field_id;
      SCInteger field_options;
      DataType_iplength field_len;
      DataType_iplength field_cs;
      SCBoolean field_df;
      DataType_tcp field_data;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_ip(*this);
      }
      // Zuweisungsoperator:
      DataType_ip& operator= (const DataType_ip &orig)
      {
        field_src = orig.field_src;
        field_dst = orig.field_dst;
        field_prot = orig.field_prot;
        field_tos = orig.field_tos;
        field_ttl = orig.field_ttl;
        field_id = orig.field_id;
        field_options = orig.field_options;
        field_len = orig.field_len;
        field_cs = orig.field_cs;
        field_df = orig.field_df;
        field_data = orig.field_data;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_ip &second) const
      {
        return (field_src == second.field_src && field_dst == second.field_dst &&
                field_prot == second.field_prot && field_tos == second.field_tos &&
                field_ttl == second.field_ttl && field_id == second.field_id &&
                field_options == second.field_options && field_len == second.field_len &&
                field_cs == second.field_cs && field_df == second.field_df &&
                field_data == second.field_data);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_ip *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_ip &me)
      {
        out << "[";
        out << me.field_src << ", ";
        out << me.field_dst << ", ";
        out << me.field_prot << ", ";
        out << me.field_tos << ", ";
        out << me.field_ttl << ", ";
        out << me.field_id << ", ";
        out << me.field_options << ", ";
        out << me.field_len << ", ";
        out << me.field_cs << ", ";
        out << me.field_df << ", ";
        out << me.field_data;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_src, sizeof(SCInteger));
        save_area.Store(&field_dst, sizeof(SCInteger));
        save_area.Store(&field_prot, sizeof(SCInteger));
        save_area.Store(&field_tos, sizeof(SCInteger));
        save_area.Store(&field_ttl, sizeof(SCInteger));
        save_area.Store(&field_id, sizeof(SCInteger));
        save_area.Store(&field_options, sizeof(SCInteger));
        field_len.Save(save_area);
        field_cs.Save(save_area);
        save_area.Store(&field_df, sizeof(SCBoolean));
        field_data.Save(save_area);
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_src, sizeof(SCInteger));
        save_area.HistoryStore(&field_dst, sizeof(SCInteger));
        save_area.HistoryStore(&field_prot, sizeof(SCInteger));
        save_area.HistoryStore(&field_tos, sizeof(SCInteger));
        save_area.HistoryStore(&field_ttl, sizeof(SCInteger));
        save_area.HistoryStore(&field_id, sizeof(SCInteger));
        save_area.HistoryStore(&field_options, sizeof(SCInteger));
        field_len.HistorySave(save_area);
        field_cs.HistorySave(save_area);
        save_area.HistoryStore(&field_df, sizeof(SCBoolean));
        field_data.HistorySave(save_area);
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_src, sizeof(SCInteger));
        save_area.Restore(&field_dst, sizeof(SCInteger));
        save_area.Restore(&field_prot, sizeof(SCInteger));
        save_area.Restore(&field_tos, sizeof(SCInteger));
        save_area.Restore(&field_ttl, sizeof(SCInteger));
        save_area.Restore(&field_id, sizeof(SCInteger));
        save_area.Restore(&field_options, sizeof(SCInteger));
        field_len.Restore(save_area);
        field_cs.Restore(save_area);
        save_area.Restore(&field_df, sizeof(SCBoolean));
        field_data.Restore(save_area);
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_src, sizeof(SCInteger));
        save_area.HistoryRestore(&field_dst, sizeof(SCInteger));
        save_area.HistoryRestore(&field_prot, sizeof(SCInteger));
        save_area.HistoryRestore(&field_tos, sizeof(SCInteger));
        save_area.HistoryRestore(&field_ttl, sizeof(SCInteger));
        save_area.HistoryRestore(&field_id, sizeof(SCInteger));
        save_area.HistoryRestore(&field_options, sizeof(SCInteger));
        field_len.HistoryRestore(save_area);
        field_cs.HistoryRestore(save_area);
        save_area.HistoryRestore(&field_df, sizeof(SCBoolean));
        field_data.HistoryRestore(save_area);
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        field_len.Size(cur_size);
        field_cs.Size(cur_size);
        cur_size->size += sizeof(SCBoolean);
        field_data.Size(cur_size);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        field_len.HistorySize(cur_size);
        field_cs.HistorySize(cur_size);
        cur_size->historySize += sizeof(SCBoolean);
        field_data.HistorySize(cur_size);
      }
    };

    /**************************************************************************
     * SDL-Newtype: Struct 'retransmitpacket':
     *************************************************************************/

    struct DataType_retransmitpacket : public SCDataType
    {
      // Default Konstruktor:
      DataType_retransmitpacket(void)
      {
        field_failed_retransmit = 0;
        field_activ = false;
      }
      // Copy Konstruktor:
      DataType_retransmitpacket(const DataType_retransmitpacket& orig)
      {
        *this = orig;
      }
      // Felder:
      DataType_tcp field_tcp_packet;
      SCInteger field_failed_retransmit;
      SCBoolean field_activ;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_retransmitpacket(*this);
      }
      // Zuweisungsoperator:
      DataType_retransmitpacket& operator= (const DataType_retransmitpacket &orig)
      {
        field_tcp_packet = orig.field_tcp_packet;
        field_failed_retransmit = orig.field_failed_retransmit;
        field_activ = orig.field_activ;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_retransmitpacket &second) const
      {
        return (field_tcp_packet == second.field_tcp_packet &&
                field_failed_retransmit == second.field_failed_retransmit &&
                field_activ == second.field_activ);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_retransmitpacket *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_retransmitpacket &me)
      {
        out << "[";
        out << me.field_tcp_packet << ", ";
        out << me.field_failed_retransmit << ", ";
        out << me.field_activ;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        field_tcp_packet.Save(save_area);
        save_area.Store(&field_failed_retransmit, sizeof(SCInteger));
        save_area.Store(&field_activ, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        field_tcp_packet.HistorySave(save_area);
        save_area.HistoryStore(&field_failed_retransmit, sizeof(SCInteger));
        save_area.HistoryStore(&field_activ, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        field_tcp_packet.Restore(save_area);
        save_area.Restore(&field_failed_retransmit, sizeof(SCInteger));
        save_area.Restore(&field_activ, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        field_tcp_packet.HistoryRestore(save_area);
        save_area.HistoryRestore(&field_failed_retransmit, sizeof(SCInteger));
        save_area.HistoryRestore(&field_activ, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        field_tcp_packet.Size(cur_size);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        field_tcp_packet.HistorySize(cur_size);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCBoolean);
      }
    };

    /**************************************************************************
     * SDL-Newtype: Array 'listofretrpackets':
     *************************************************************************/

    struct DataType_listofretrpackets : public SCArray<DataType_retransmitpacket>
    {
      // Konstruktor:
      DataType_listofretrpackets(void) : SCArray<DataType_retransmitpacket> (0,
                                                                             syn_buffer_size) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        SCInteger i;

        for (i = lowBound; i <= highBound; i++)
        {
          (*this)[i].Save(save_area);
        }

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        SCInteger i;

        for (i = lowBound; i <= highBound; i++)
        {
          (*this)[i].HistorySave(save_area);
        }

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        SCInteger i;

        for (i = lowBound; i <= highBound; i++)
        {
          (*this)[i].Restore(save_area);
        }

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        SCInteger i;

        for (i = lowBound; i <= highBound; i++)
        {
          (*this)[i].HistoryRestore(save_area);
        }

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        SCSize elemSize;

        (*this)[lowBound].Size(&elemSize);
        cur_size->size += ((highBound - lowBound + 1) * elemSize.size);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        SCSize elemSize;

        (*this)[lowBound].HistorySize(&elemSize);
        cur_size->historySize += ((highBound - lowBound + 1) * elemSize.historySize);
      }
    };
    /**************************************************************************
     * SDL-Newtype: Array 'portaddr':
     *************************************************************************/

    struct DataType_portaddr : public SCArray<SCPid>
    {
      // Konstruktor:
      DataType_portaddr(void) : SCArray<SCPid> (0, 256, (SCPid)0L) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
    };
    /**************************************************************************
     * SDL-Newtype: Struct 'transmitdata':
     *************************************************************************/

    struct DataType_transmitdata : public SCDataType
    {
      // Default Konstruktor:
      DataType_transmitdata(void)
      {
        field_len = 0;
        field_urgp = 0;
        field_pshp = 0;
        field_fin = false;
        field_urg = false;
        field_psh = false;
      }
      // Copy Konstruktor:
      DataType_transmitdata(const DataType_transmitdata& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_len;
      SCInteger field_urgp;
      SCInteger field_pshp;
      SCBoolean field_fin;
      SCBoolean field_urg;
      SCBoolean field_psh;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_transmitdata(*this);
      }
      // Zuweisungsoperator:
      DataType_transmitdata& operator= (const DataType_transmitdata &orig)
      {
        field_len = orig.field_len;
        field_urgp = orig.field_urgp;
        field_pshp = orig.field_pshp;
        field_fin = orig.field_fin;
        field_urg = orig.field_urg;
        field_psh = orig.field_psh;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_transmitdata &second) const
      {
        return (field_len == second.field_len && field_urgp == second.field_urgp &&
                field_pshp == second.field_pshp && field_fin == second.field_fin &&
                field_urg == second.field_urg && field_psh == second.field_psh);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_transmitdata *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_transmitdata &me)
      {
        out << "[";
        out << me.field_len << ", ";
        out << me.field_urgp << ", ";
        out << me.field_pshp << ", ";
        out << me.field_fin << ", ";
        out << me.field_urg << ", ";
        out << me.field_psh;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_len, sizeof(SCInteger));
        save_area.Store(&field_urgp, sizeof(SCInteger));
        save_area.Store(&field_pshp, sizeof(SCInteger));
        save_area.Store(&field_fin, sizeof(SCBoolean));
        save_area.Store(&field_urg, sizeof(SCBoolean));
        save_area.Store(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_len, sizeof(SCInteger));
        save_area.HistoryStore(&field_urgp, sizeof(SCInteger));
        save_area.HistoryStore(&field_pshp, sizeof(SCInteger));
        save_area.HistoryStore(&field_fin, sizeof(SCBoolean));
        save_area.HistoryStore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryStore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_len, sizeof(SCInteger));
        save_area.Restore(&field_urgp, sizeof(SCInteger));
        save_area.Restore(&field_pshp, sizeof(SCInteger));
        save_area.Restore(&field_fin, sizeof(SCBoolean));
        save_area.Restore(&field_urg, sizeof(SCBoolean));
        save_area.Restore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_len, sizeof(SCInteger));
        save_area.HistoryRestore(&field_urgp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_pshp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_fin, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_psh, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
      }
    };

    /**************************************************************************
     * SDL-Newtype: Struct 'tcbblock':
     *************************************************************************/

    struct DataType_tcbblock : public SCDataType
    {
      // Default Konstruktor:
      DataType_tcbblock(void)
      {
        field_sp = 0;
        field_da = 0;
        field_dp = 0;
        field_tout = 0;
        field_toa = 0;
        field_prec = 0;
        field_sec = 0;
        field_isn = 0;
        field_iss = 0;
        field_aaa = 0;
        field_aar = 0;
        field_urg = false;
        field_psh = false;
      }
      // Copy Konstruktor:
      DataType_tcbblock(const DataType_tcbblock& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_sp;
      SCInteger field_da;
      SCInteger field_dp;
      SCInteger field_tout;
      SCInteger field_toa;
      SCInteger field_prec;
      SCInteger field_sec;
      SCInteger field_isn;
      SCInteger field_iss;
      SCInteger field_aaa;
      SCInteger field_aar;
      SCBoolean field_urg;
      SCBoolean field_psh;
      DataType_windowsize field_snd_nxt;
      DataType_windowsize field_rcv_nxt;
      DataType_windowsize field_snd_wnd;
      DataType_windowsize field_rcv_wnd;
      DataType_windowsize field_snd_una;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_tcbblock(*this);
      }
      // Zuweisungsoperator:
      DataType_tcbblock& operator= (const DataType_tcbblock &orig)
      {
        field_sp = orig.field_sp;
        field_da = orig.field_da;
        field_dp = orig.field_dp;
        field_tout = orig.field_tout;
        field_toa = orig.field_toa;
        field_prec = orig.field_prec;
        field_sec = orig.field_sec;
        field_isn = orig.field_isn;
        field_iss = orig.field_iss;
        field_aaa = orig.field_aaa;
        field_aar = orig.field_aar;
        field_urg = orig.field_urg;
        field_psh = orig.field_psh;
        field_snd_nxt = orig.field_snd_nxt;
        field_rcv_nxt = orig.field_rcv_nxt;
        field_snd_wnd = orig.field_snd_wnd;
        field_rcv_wnd = orig.field_rcv_wnd;
        field_snd_una = orig.field_snd_una;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_tcbblock &second) const
      {
        return (field_sp == second.field_sp && field_da == second.field_da &&
                field_dp == second.field_dp && field_tout == second.field_tout &&
                field_toa == second.field_toa && field_prec == second.field_prec &&
                field_sec == second.field_sec && field_isn == second.field_isn &&
                field_iss == second.field_iss && field_aaa == second.field_aaa &&
                field_aar == second.field_aar && field_urg == second.field_urg &&
                field_psh == second.field_psh && field_snd_nxt == second.field_snd_nxt &&
                field_rcv_nxt == second.field_rcv_nxt && field_snd_wnd == second.field_snd_wnd &&
                field_rcv_wnd == second.field_rcv_wnd && field_snd_una == second.field_snd_una);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_tcbblock *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_tcbblock &me)
      {
        out << "[";
        out << me.field_sp << ", ";
        out << me.field_da << ", ";
        out << me.field_dp << ", ";
        out << me.field_tout << ", ";
        out << me.field_toa << ", ";
        out << me.field_prec << ", ";
        out << me.field_sec << ", ";
        out << me.field_isn << ", ";
        out << me.field_iss << ", ";
        out << me.field_aaa << ", ";
        out << me.field_aar << ", ";
        out << me.field_urg << ", ";
        out << me.field_psh << ", ";
        out << me.field_snd_nxt << ", ";
        out << me.field_rcv_nxt << ", ";
        out << me.field_snd_wnd << ", ";
        out << me.field_rcv_wnd << ", ";
        out << me.field_snd_una;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_sp, sizeof(SCInteger));
        save_area.Store(&field_da, sizeof(SCInteger));
        save_area.Store(&field_dp, sizeof(SCInteger));
        save_area.Store(&field_tout, sizeof(SCInteger));
        save_area.Store(&field_toa, sizeof(SCInteger));
        save_area.Store(&field_prec, sizeof(SCInteger));
        save_area.Store(&field_sec, sizeof(SCInteger));
        save_area.Store(&field_isn, sizeof(SCInteger));
        save_area.Store(&field_iss, sizeof(SCInteger));
        save_area.Store(&field_aaa, sizeof(SCInteger));
        save_area.Store(&field_aar, sizeof(SCInteger));
        save_area.Store(&field_urg, sizeof(SCBoolean));
        save_area.Store(&field_psh, sizeof(SCBoolean));
        field_snd_nxt.Save(save_area);
        field_rcv_nxt.Save(save_area);
        field_snd_wnd.Save(save_area);
        field_rcv_wnd.Save(save_area);
        field_snd_una.Save(save_area);
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_sp, sizeof(SCInteger));
        save_area.HistoryStore(&field_da, sizeof(SCInteger));
        save_area.HistoryStore(&field_dp, sizeof(SCInteger));
        save_area.HistoryStore(&field_tout, sizeof(SCInteger));
        save_area.HistoryStore(&field_toa, sizeof(SCInteger));
        save_area.HistoryStore(&field_prec, sizeof(SCInteger));
        save_area.HistoryStore(&field_sec, sizeof(SCInteger));
        save_area.HistoryStore(&field_isn, sizeof(SCInteger));
        save_area.HistoryStore(&field_iss, sizeof(SCInteger));
        save_area.HistoryStore(&field_aaa, sizeof(SCInteger));
        save_area.HistoryStore(&field_aar, sizeof(SCInteger));
        save_area.HistoryStore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryStore(&field_psh, sizeof(SCBoolean));
        field_snd_nxt.HistorySave(save_area);
        field_rcv_nxt.HistorySave(save_area);
        field_snd_wnd.HistorySave(save_area);
        field_rcv_wnd.HistorySave(save_area);
        field_snd_una.HistorySave(save_area);
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_sp, sizeof(SCInteger));
        save_area.Restore(&field_da, sizeof(SCInteger));
        save_area.Restore(&field_dp, sizeof(SCInteger));
        save_area.Restore(&field_tout, sizeof(SCInteger));
        save_area.Restore(&field_toa, sizeof(SCInteger));
        save_area.Restore(&field_prec, sizeof(SCInteger));
        save_area.Restore(&field_sec, sizeof(SCInteger));
        save_area.Restore(&field_isn, sizeof(SCInteger));
        save_area.Restore(&field_iss, sizeof(SCInteger));
        save_area.Restore(&field_aaa, sizeof(SCInteger));
        save_area.Restore(&field_aar, sizeof(SCInteger));
        save_area.Restore(&field_urg, sizeof(SCBoolean));
        save_area.Restore(&field_psh, sizeof(SCBoolean));
        field_snd_nxt.Restore(save_area);
        field_rcv_nxt.Restore(save_area);
        field_snd_wnd.Restore(save_area);
        field_rcv_wnd.Restore(save_area);
        field_snd_una.Restore(save_area);
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_sp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_da, sizeof(SCInteger));
        save_area.HistoryRestore(&field_dp, sizeof(SCInteger));
        save_area.HistoryRestore(&field_tout, sizeof(SCInteger));
        save_area.HistoryRestore(&field_toa, sizeof(SCInteger));
        save_area.HistoryRestore(&field_prec, sizeof(SCInteger));
        save_area.HistoryRestore(&field_sec, sizeof(SCInteger));
        save_area.HistoryRestore(&field_isn, sizeof(SCInteger));
        save_area.HistoryRestore(&field_iss, sizeof(SCInteger));
        save_area.HistoryRestore(&field_aaa, sizeof(SCInteger));
        save_area.HistoryRestore(&field_aar, sizeof(SCInteger));
        save_area.HistoryRestore(&field_urg, sizeof(SCBoolean));
        save_area.HistoryRestore(&field_psh, sizeof(SCBoolean));
        field_snd_nxt.HistoryRestore(save_area);
        field_rcv_nxt.HistoryRestore(save_area);
        field_snd_wnd.HistoryRestore(save_area);
        field_rcv_wnd.HistoryRestore(save_area);
        field_snd_una.HistoryRestore(save_area);
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        field_snd_nxt.Size(cur_size);
        field_rcv_nxt.Size(cur_size);
        field_snd_wnd.Size(cur_size);
        field_rcv_wnd.Size(cur_size);
        field_snd_una.Size(cur_size);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCBoolean);
        cur_size->historySize += sizeof(SCBoolean);
        field_snd_nxt.HistorySize(cur_size);
        field_rcv_nxt.HistorySize(cur_size);
        field_snd_wnd.HistorySize(cur_size);
        field_rcv_wnd.HistorySize(cur_size);
        field_snd_una.HistorySize(cur_size);
      }
    };


    /**************************************************************************
     * IDs der Signaltypen auf Systemebene
     *************************************************************************/

    enum
    {
      sig_type_id_status = kSCSignalTypeIDBase + 0,
      sig_type_id_close,
      sig_type_id_abort,
      sig_type_id_os,
      sig_type_id_of,
      sig_type_id_process_terminated,
      sig_type_id_closing,
      sig_type_id_upo,
      sig_type_id_fspo,
      sig_type_id_ao,
      sig_type_id_aod,
      sig_type_id_send,
      sig_type_id_allocate,
      sig_type_id_oid,
      sig_type_id_del,
      sig_type_id_ter,
      sig_type_id_err,
      sig_type_id_stresp,
      sig_type_id_tcp_packet,
      sig_type_id_ip_packet
    };

    /**************************************************************************
     * Strukturen fuer die Signalparameter auf Systemebene
     *************************************************************************/

    struct SigParam_status : public SCDataType
    {
      // Default Konstruktor:
      SigParam_status(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_status(const SigParam_status& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_status(*this);
      }
      // Zuweisungsoperator:
      SigParam_status& operator= (const SigParam_status &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_status &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_status *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_status &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_close : public SCDataType
    {
      // Default Konstruktor:
      SigParam_close(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_close(const SigParam_close& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_close(*this);
      }
      // Zuweisungsoperator:
      SigParam_close& operator= (const SigParam_close &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_close &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_close *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_close &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_abort : public SCDataType
    {
      // Default Konstruktor:
      SigParam_abort(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_abort(const SigParam_abort& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_abort(*this);
      }
      // Zuweisungsoperator:
      SigParam_abort& operator= (const SigParam_abort &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_abort &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_abort *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_abort &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_os : public SCDataType
    {
      // Default Konstruktor:
      SigParam_os(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_os(const SigParam_os& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_os(*this);
      }
      // Zuweisungsoperator:
      SigParam_os& operator= (const SigParam_os &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_os &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_os *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_os &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_of : public SCDataType
    {
      // Default Konstruktor:
      SigParam_of(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_of(const SigParam_of& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_of(*this);
      }
      // Zuweisungsoperator:
      SigParam_of& operator= (const SigParam_of &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_of &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_of *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_of &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_process_terminated : public SCDataType
    {
      // Default Konstruktor:
      SigParam_process_terminated(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_process_terminated(const SigParam_process_terminated& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_process_terminated(*this);
      }
      // Zuweisungsoperator:
      SigParam_process_terminated& operator= (const SigParam_process_terminated &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_process_terminated &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_process_terminated *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_process_terminated &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_closing : public SCDataType
    {
      // Default Konstruktor:
      SigParam_closing(void)
      {
        sig_field_1 = 0;
      }
      // Copy Konstruktor:
      SigParam_closing(const SigParam_closing& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_closing(*this);
      }
      // Zuweisungsoperator:
      SigParam_closing& operator= (const SigParam_closing &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_closing &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_closing *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_closing &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_upo : public SCDataType
    {
      // Default Konstruktor:
      SigParam_upo(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
        sig_field_5 = 0;
      }
      // Copy Konstruktor:
      SigParam_upo(const SigParam_upo& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      SCInteger sig_field_5;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_upo(*this);
      }
      // Zuweisungsoperator:
      SigParam_upo& operator= (const SigParam_upo &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_upo &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_upo *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_upo &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_fspo : public SCDataType
    {
      // Default Konstruktor:
      SigParam_fspo(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
        sig_field_5 = 0;
        sig_field_6 = 0;
        sig_field_7 = 0;
      }
      // Copy Konstruktor:
      SigParam_fspo(const SigParam_fspo& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      SCInteger sig_field_5;
      SCInteger sig_field_6;
      SCInteger sig_field_7;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_fspo(*this);
      }
      // Zuweisungsoperator:
      SigParam_fspo& operator= (const SigParam_fspo &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        sig_field_6 = orig.sig_field_6;
        sig_field_7 = orig.sig_field_7;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_fspo &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5 && sig_field_6 == second.sig_field_6 &&
                sig_field_7 == second.sig_field_7);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_fspo *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_fspo &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5 << ", ";
        out << me.sig_field_6 << ", ";
        out << me.sig_field_7;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        save_area.Store(&sig_field_6, sizeof(SCInteger));
        save_area.Store(&sig_field_7, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        save_area.Restore(&sig_field_6, sizeof(SCInteger));
        save_area.Restore(&sig_field_7, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_ao : public SCDataType
    {
      // Default Konstruktor:
      SigParam_ao(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
        sig_field_5 = 0;
        sig_field_6 = 0;
        sig_field_7 = 0;
      }
      // Copy Konstruktor:
      SigParam_ao(const SigParam_ao& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      SCInteger sig_field_5;
      SCInteger sig_field_6;
      SCInteger sig_field_7;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_ao(*this);
      }
      // Zuweisungsoperator:
      SigParam_ao& operator= (const SigParam_ao &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        sig_field_6 = orig.sig_field_6;
        sig_field_7 = orig.sig_field_7;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_ao &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5 && sig_field_6 == second.sig_field_6 &&
                sig_field_7 == second.sig_field_7);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_ao *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_ao &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5 << ", ";
        out << me.sig_field_6 << ", ";
        out << me.sig_field_7;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        save_area.Store(&sig_field_6, sizeof(SCInteger));
        save_area.Store(&sig_field_7, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        save_area.Restore(&sig_field_6, sizeof(SCInteger));
        save_area.Restore(&sig_field_7, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_aod : public SCDataType
    {
      // Default Konstruktor:
      SigParam_aod(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
        sig_field_5 = 0;
        sig_field_6 = 0;
        sig_field_7 = 0;
        sig_field_8 = 0;
        sig_field_9 = false;
        sig_field_10 = false;
      }
      // Copy Konstruktor:
      SigParam_aod(const SigParam_aod& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      SCInteger sig_field_5;
      SCInteger sig_field_6;
      SCInteger sig_field_7;
      SCInteger sig_field_8;
      SCBoolean sig_field_9;
      SCBoolean sig_field_10;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_aod(*this);
      }
      // Zuweisungsoperator:
      SigParam_aod& operator= (const SigParam_aod &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        sig_field_6 = orig.sig_field_6;
        sig_field_7 = orig.sig_field_7;
        sig_field_8 = orig.sig_field_8;
        sig_field_9 = orig.sig_field_9;
        sig_field_10 = orig.sig_field_10;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_aod &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5 && sig_field_6 == second.sig_field_6 &&
                sig_field_7 == second.sig_field_7 && sig_field_8 == second.sig_field_8 &&
                sig_field_9 == second.sig_field_9 && sig_field_10 == second.sig_field_10);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_aod *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_aod &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5 << ", ";
        out << me.sig_field_6 << ", ";
        out << me.sig_field_7 << ", ";
        out << me.sig_field_8 << ", ";
        out << me.sig_field_9 << ", ";
        out << me.sig_field_10;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        save_area.Store(&sig_field_6, sizeof(SCInteger));
        save_area.Store(&sig_field_7, sizeof(SCInteger));
        save_area.Store(&sig_field_8, sizeof(SCInteger));
        save_area.Store(&sig_field_9, sizeof(SCBoolean));
        save_area.Store(&sig_field_10, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        save_area.Restore(&sig_field_6, sizeof(SCInteger));
        save_area.Restore(&sig_field_7, sizeof(SCInteger));
        save_area.Restore(&sig_field_8, sizeof(SCInteger));
        save_area.Restore(&sig_field_9, sizeof(SCBoolean));
        save_area.Restore(&sig_field_10, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
      }
    };
    struct SigParam_send : public SCDataType
    {
      // Default Konstruktor:
      SigParam_send(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = false;
        sig_field_4 = false;
        sig_field_5 = 0;
        sig_field_6 = 0;
      }
      // Copy Konstruktor:
      SigParam_send(const SigParam_send& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCBoolean sig_field_3;
      SCBoolean sig_field_4;
      SCInteger sig_field_5;
      SCInteger sig_field_6;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_send(*this);
      }
      // Zuweisungsoperator:
      SigParam_send& operator= (const SigParam_send &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        sig_field_6 = orig.sig_field_6;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_send &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5 && sig_field_6 == second.sig_field_6);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_send *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_send &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5 << ", ";
        out << me.sig_field_6;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCBoolean));
        save_area.Store(&sig_field_4, sizeof(SCBoolean));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        save_area.Store(&sig_field_6, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCBoolean));
        save_area.Restore(&sig_field_4, sizeof(SCBoolean));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        save_area.Restore(&sig_field_6, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_allocate : public SCDataType
    {
      // Default Konstruktor:
      SigParam_allocate(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
      }
      // Copy Konstruktor:
      SigParam_allocate(const SigParam_allocate& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_allocate(*this);
      }
      // Zuweisungsoperator:
      SigParam_allocate& operator= (const SigParam_allocate &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_allocate &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_allocate *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_allocate &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_oid : public SCDataType
    {
      // Default Konstruktor:
      SigParam_oid(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
      }
      // Copy Konstruktor:
      SigParam_oid(const SigParam_oid& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_oid(*this);
      }
      // Zuweisungsoperator:
      SigParam_oid& operator= (const SigParam_oid &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_oid &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_oid *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_oid &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_del : public SCDataType
    {
      // Default Konstruktor:
      SigParam_del(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = false;
      }
      // Copy Konstruktor:
      SigParam_del(const SigParam_del& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCBoolean sig_field_3;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_del(*this);
      }
      // Zuweisungsoperator:
      SigParam_del& operator= (const SigParam_del &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_del &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_del *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_del &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCBoolean));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
      }
    };
    struct SigParam_ter : public SCDataType
    {
      // Default Konstruktor:
      SigParam_ter(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
      }
      // Copy Konstruktor:
      SigParam_ter(const SigParam_ter& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_ter(*this);
      }
      // Zuweisungsoperator:
      SigParam_ter& operator= (const SigParam_ter &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_ter &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_ter *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_ter &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_err : public SCDataType
    {
      // Default Konstruktor:
      SigParam_err(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
      }
      // Copy Konstruktor:
      SigParam_err(const SigParam_err& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_err(*this);
      }
      // Zuweisungsoperator:
      SigParam_err& operator= (const SigParam_err &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_err &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_err *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_err &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_stresp : public SCDataType
    {
      // Default Konstruktor:
      SigParam_stresp(void)
      {
        sig_field_1 = 0;
        sig_field_2 = 0;
        sig_field_3 = 0;
        sig_field_4 = 0;
        sig_field_5 = 0;
        sig_field_6 = 0;
        sig_field_7 = 0;
        sig_field_8 = false;
        sig_field_9 = 0;
        sig_field_10 = 0;
        sig_field_11 = 0;
      }
      // Copy Konstruktor:
      SigParam_stresp(const SigParam_stresp& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      SCInteger sig_field_1;
      SCInteger sig_field_2;
      SCInteger sig_field_3;
      SCInteger sig_field_4;
      SCInteger sig_field_5;
      SCInteger sig_field_6;
      SCInteger sig_field_7;
      SCBoolean sig_field_8;
      SCInteger sig_field_9;
      SCInteger sig_field_10;
      SCInteger sig_field_11;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_stresp(*this);
      }
      // Zuweisungsoperator:
      SigParam_stresp& operator= (const SigParam_stresp &orig)
      {
        sig_field_1 = orig.sig_field_1;
        sig_field_2 = orig.sig_field_2;
        sig_field_3 = orig.sig_field_3;
        sig_field_4 = orig.sig_field_4;
        sig_field_5 = orig.sig_field_5;
        sig_field_6 = orig.sig_field_6;
        sig_field_7 = orig.sig_field_7;
        sig_field_8 = orig.sig_field_8;
        sig_field_9 = orig.sig_field_9;
        sig_field_10 = orig.sig_field_10;
        sig_field_11 = orig.sig_field_11;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_stresp &second) const
      {
        return (sig_field_1 == second.sig_field_1 && sig_field_2 == second.sig_field_2 &&
                sig_field_3 == second.sig_field_3 && sig_field_4 == second.sig_field_4 &&
                sig_field_5 == second.sig_field_5 && sig_field_6 == second.sig_field_6 &&
                sig_field_7 == second.sig_field_7 && sig_field_8 == second.sig_field_8 &&
                sig_field_9 == second.sig_field_9 && sig_field_10 == second.sig_field_10 &&
                sig_field_11 == second.sig_field_11);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_stresp *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_stresp &me)
      {
        out << "[";
        out << me.sig_field_1 << ", ";
        out << me.sig_field_2 << ", ";
        out << me.sig_field_3 << ", ";
        out << me.sig_field_4 << ", ";
        out << me.sig_field_5 << ", ";
        out << me.sig_field_6 << ", ";
        out << me.sig_field_7 << ", ";
        out << me.sig_field_8 << ", ";
        out << me.sig_field_9 << ", ";
        out << me.sig_field_10 << ", ";
        out << me.sig_field_11;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&sig_field_1, sizeof(SCInteger));
        save_area.Store(&sig_field_2, sizeof(SCInteger));
        save_area.Store(&sig_field_3, sizeof(SCInteger));
        save_area.Store(&sig_field_4, sizeof(SCInteger));
        save_area.Store(&sig_field_5, sizeof(SCInteger));
        save_area.Store(&sig_field_6, sizeof(SCInteger));
        save_area.Store(&sig_field_7, sizeof(SCInteger));
        save_area.Store(&sig_field_8, sizeof(SCBoolean));
        save_area.Store(&sig_field_9, sizeof(SCInteger));
        save_area.Store(&sig_field_10, sizeof(SCInteger));
        save_area.Store(&sig_field_11, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&sig_field_1, sizeof(SCInteger));
        save_area.Restore(&sig_field_2, sizeof(SCInteger));
        save_area.Restore(&sig_field_3, sizeof(SCInteger));
        save_area.Restore(&sig_field_4, sizeof(SCInteger));
        save_area.Restore(&sig_field_5, sizeof(SCInteger));
        save_area.Restore(&sig_field_6, sizeof(SCInteger));
        save_area.Restore(&sig_field_7, sizeof(SCInteger));
        save_area.Restore(&sig_field_8, sizeof(SCBoolean));
        save_area.Restore(&sig_field_9, sizeof(SCInteger));
        save_area.Restore(&sig_field_10, sizeof(SCInteger));
        save_area.Restore(&sig_field_11, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCBoolean);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
    };
    struct SigParam_tcp_packet : public SCDataType
    {
      // Default Konstruktor:
      SigParam_tcp_packet(void)
      {
      }
      // Copy Konstruktor:
      SigParam_tcp_packet(const SigParam_tcp_packet& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      DataType_tcp sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_tcp_packet(*this);
      }
      // Zuweisungsoperator:
      SigParam_tcp_packet& operator= (const SigParam_tcp_packet &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_tcp_packet &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_tcp_packet *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_tcp_packet &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        sig_field_1.Save(save_area);
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        sig_field_1.Restore(save_area);
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        sig_field_1.Size(cur_size);
      }
    };
    struct SigParam_ip_packet : public SCDataType
    {
      // Default Konstruktor:
      SigParam_ip_packet(void)
      {
      }
      // Copy Konstruktor:
      SigParam_ip_packet(const SigParam_ip_packet& orig)
      {
        *this = orig;
      }
      // Signalparameter:
      DataType_ip sig_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new SigParam_ip_packet(*this);
      }
      // Zuweisungsoperator:
      SigParam_ip_packet& operator= (const SigParam_ip_packet &orig)
      {
        sig_field_1 = orig.sig_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const SigParam_ip_packet &second) const
      {
        return (sig_field_1 == second.sig_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(SigParam_ip_packet *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const SigParam_ip_packet &me)
      {
        out << me.sig_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        sig_field_1.Save(save_area);
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        sig_field_1.Restore(save_area);
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        sig_field_1.Size(cur_size);
      }
    };

    /**************************************************************************
     * Variablen fuer die Signalparameter auf Systemebene
     *************************************************************************/

    SigParam_status *sigparam_status;
    SigParam_close *sigparam_close;
    SigParam_abort *sigparam_abort;
    SigParam_os *sigparam_os;
    SigParam_of *sigparam_of;
    SigParam_process_terminated *sigparam_process_terminated;
    SigParam_closing *sigparam_closing;
    SigParam_upo *sigparam_upo;
    SigParam_fspo *sigparam_fspo;
    SigParam_ao *sigparam_ao;
    SigParam_aod *sigparam_aod;
    SigParam_send *sigparam_send;
    SigParam_allocate *sigparam_allocate;
    SigParam_oid *sigparam_oid;
    SigParam_del *sigparam_del;
    SigParam_ter *sigparam_ter;
    SigParam_err *sigparam_err;
    SigParam_stresp *sigparam_stresp;
    SigParam_tcp_packet *sigparam_tcp_packet;
    SigParam_ip_packet *sigparam_ip_packet;

    /**************************************************************************
     * Signaltypen auf Systemebene (statisch)
     *************************************************************************/

    struct SigType_status: public SCSignalType
    {
      SigType_status(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_status;
      }
    };
    static SigType_status * sig_type_status;
    struct SigType_close: public SCSignalType
    {
      SigType_close(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_close;
      }
    };
    static SigType_close * sig_type_close;
    struct SigType_abort: public SCSignalType
    {
      SigType_abort(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_abort;
      }
    };
    static SigType_abort * sig_type_abort;
    struct SigType_os: public SCSignalType
    {
      SigType_os(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_os;
      }
    };
    static SigType_os * sig_type_os;
    struct SigType_of: public SCSignalType
    {
      SigType_of(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_of;
      }
    };
    static SigType_of * sig_type_of;
    struct SigType_process_terminated: public SCSignalType
    {
      SigType_process_terminated(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_process_terminated;
      }
    };
    static SigType_process_terminated * sig_type_process_terminated;
    struct SigType_closing: public SCSignalType
    {
      SigType_closing(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_closing;
      }
    };
    static SigType_closing * sig_type_closing;
    struct SigType_upo: public SCSignalType
    {
      SigType_upo(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_upo;
      }
    };
    static SigType_upo * sig_type_upo;
    struct SigType_fspo: public SCSignalType
    {
      SigType_fspo(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_fspo;
      }
    };
    static SigType_fspo * sig_type_fspo;
    struct SigType_ao: public SCSignalType
    {
      SigType_ao(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_ao;
      }
    };
    static SigType_ao * sig_type_ao;
    struct SigType_aod: public SCSignalType
    {
      SigType_aod(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_aod;
      }
    };
    static SigType_aod * sig_type_aod;
    struct SigType_send: public SCSignalType
    {
      SigType_send(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_send;
      }
    };
    static SigType_send * sig_type_send;
    struct SigType_allocate: public SCSignalType
    {
      SigType_allocate(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_allocate;
      }
    };
    static SigType_allocate * sig_type_allocate;
    struct SigType_oid: public SCSignalType
    {
      SigType_oid(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_oid;
      }
    };
    static SigType_oid * sig_type_oid;
    struct SigType_del: public SCSignalType
    {
      SigType_del(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_del;
      }
    };
    static SigType_del * sig_type_del;
    struct SigType_ter: public SCSignalType
    {
      SigType_ter(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_ter;
      }
    };
    static SigType_ter * sig_type_ter;
    struct SigType_err: public SCSignalType
    {
      SigType_err(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_err;
      }
    };
    static SigType_err * sig_type_err;
    struct SigType_stresp: public SCSignalType
    {
      SigType_stresp(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_stresp;
      }
    };
    static SigType_stresp * sig_type_stresp;
    struct SigType_tcp_packet: public SCSignalType
    {
      SigType_tcp_packet(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_tcp_packet;
      }
    };
    static SigType_tcp_packet * sig_type_tcp_packet;
    struct SigType_ip_packet: public SCSignalType
    {
      SigType_ip_packet(SCNatural type_key, const char *type_name) :
        SCSignalType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new SigParam_ip_packet;
      }
    };
    static SigType_ip_packet * sig_type_ip_packet;

    /**************************************************************************
     * Virtuelle Save-, Restore- und Size-Methoden
     *************************************************************************/

    SCBoolean SystemSave(SCMem &);
    SCBoolean SystemRestore(SCMem &);
    void SystemSize(SCSize *);

};

#endif
