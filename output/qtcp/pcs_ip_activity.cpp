/******************************************************************************
 *                            pcs_ip_activity.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"
#include "pcs_ip_activity.h"


#include <SCL/SCScheduler.h>
#include <SCL/SCTransition.h>

/******************************************************************************
 * Typen der SDL-Zustaende auf Prozessebene (statisch)
 *****************************************************************************/

SCStateType * pcs_ip_activity::state_type_start = NULL;
SCStateType * pcs_ip_activity::state_type_waitforinput = NULL;

/******************************************************************************
 * Input-Sets der Prozesstransitionen (statisch)
 *****************************************************************************/

SCSignalID pcs_ip_activity::input_set_waitforinput_transition0[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_ip_activity::input_set_waitforinput_transition1[] =
{
  sig_type_id_ip_packet
};

/******************************************************************************
 * Initialisierungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

SCBoolean pcs_ip_activity_data::Initialize(void)
{
  SCBoolean result = true;

  if (SCScheduler::IsVerbose())
  {
    SCScheduler::outputStream << "Initializing process activity..." << std::endl;
  }


  return result;
}

SCBoolean pcs_ip_activity::Initialize(void)
{
  SCNatural i;
  SCProcessID id;
  SCTransition *v_transition;
  SCBoolean result = true;

  /****************************************************************************
   * Initialisierung aller Zustaende des Prozesstyps:
   ***************************************************************************/

  state_type_start = new SCStateType(state_type_id_start, "start");
  state_type_waitforinput = new SCStateType(state_type_id_waitforinput,
                                            "waitforinput",
                                            0, NULL, false,
                                            false, pcs_type_activity);

  /****************************************************************************
   * Initialisierung aller Transitionen des Prozesstyps:
   ***************************************************************************/

  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_start,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition0) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition1) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);

  /****************************************************************************
   * Initiale Anzahl von Prozessinstanzen erzeugen:
   ***************************************************************************/

  for (i = 0; i < 1; i++)
  {
    id = SCScheduler::Create(pcs_type_activity);
    assert(id != kSCNoProcessID);
  }

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

void pcs_ip_activity_data::Finish(void)
{
}

void pcs_ip_activity::Finish(void)
{
  /****************************************************************************
   * Zustandstypen der Prozess-Zustaende zerstoeren:
   ***************************************************************************/

  delete state_type_start;
  delete state_type_waitforinput;

}

/******************************************************************************
 * Konstruktoren
 *****************************************************************************/

pcs_ip_activity_data::pcs_ip_activity_data(void)
{
}

pcs_ip_activity::pcs_ip_activity(const SCProcessID creator, const SCProcessType *proc_type) : 
  SCProcess(creator, proc_type, state_type_start, NULL, false)
{
#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Creating " << *this << std::endl;
  }

  /****************************************************************************
   * Variableninitialisierung:
   ***************************************************************************/


  /****************************************************************************
   * Aktuellen Zustand auf Startzustand setzen:
   ***************************************************************************/

  v_cur_state = state_type_id_start;

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

pcs_ip_activity::pcs_ip_activity(SCMem &save_area) : 
  SCProcess(false, (SCObject *)NULL)
{
  Restore(save_area);

#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Recreated " << *this << std::endl;
  }

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

pcs_ip_activity_data::~pcs_ip_activity_data(void)
{
}

pcs_ip_activity::~pcs_ip_activity(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Deleting " << *this << std::endl;
  }
}

/******************************************************************************
 * Lokale Prozeduren
 *****************************************************************************/

void pcs_ip_activity::deliver(DataType_ip v_ip_in)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_ip_in.field_dst == syn_own_address)
  {
    case false:
      break;
    case true:
      break;
  }
  switch (v_ip_in.field_len != v_ip_in.field_cs)
  {
    case true:
      break;
    case false:
      sigparam_tcp_packet = new SigParam_tcp_packet;
      assert(sigparam_tcp_packet);
      sigparam_tcp_packet->sig_field_1 = v_ip_in.field_data;
      Output(blk_tcp::pcs_type_manager, sig_type_tcp_packet,
             sigparam_tcp_packet);
      break;
  }
  return;
}

void pcs_ip_activity::sendpacket(DataType_tcp v_tcp_in)
{
  /****************************************************************************
   * Benutzerdefinierte SDL-Datentypen auf Prozedurebene
   ***************************************************************************/

  SCInteger syn_standard_ip_size = 20;
  SCInteger syn_standard_ip_protection = 0;
  SCInteger syn_standard_ip_tos = 0;
  SCInteger syn_standard_ip_ttl = 10;
  SCInteger syn_standard_ip_id = 0;
  SCBoolean syn_standard_ip_df = true;

  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_ip v_ip_out;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  v_tcp_in.field_sa = syn_own_address;
  v_ip_out.field_data = v_tcp_in;
  v_ip_out.field_len = v_tcp_in.field_len + syn_standard_ip_size;
  v_ip_out.field_src = v_tcp_in.field_sa;
  v_ip_out.field_dst = v_tcp_in.field_da;
  v_ip_out.field_cs = v_ip_out.field_len;
  v_ip_out.field_prot = syn_standard_ip_protection;
  v_ip_out.field_tos = syn_standard_ip_tos;
  v_ip_out.field_ttl = syn_standard_ip_ttl;
  v_ip_out.field_id = syn_standard_ip_id;
  v_ip_out.field_df = syn_standard_ip_df;
  sigparam_ip_packet = new SigParam_ip_packet;
  assert(sigparam_ip_packet);
  sigparam_ip_packet->sig_field_1 = v_ip_out;
  Output(blk_medium::pcs_type_transport, sig_type_ip_packet,
         sigparam_ip_packet);
  return;
}


/******************************************************************************
 * Implementierungsfunktion des SDL-Prozesses
 *****************************************************************************/

void pcs_ip_activity::Body(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Executing " << *this << std::endl;
  }

  /****************************************************************************
   * Hauptschleife:
   ***************************************************************************/

  nextstate:
  v_transition_id = kSCNoTransition;
  backtracking:
  while(true)
  {
    switch(v_cur_state)
    {
      /************************************************************************
       * Starttransition:
       ***********************************************************************/

      case state_type_id_start:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_start, kSCNoAwakeDelay,
                                  &v_signal_read);
        }
        v_cur_state = state_type_id_waitforinput;
        goto nextstate;

      /************************************************************************
       * Zustand 'waitforinput':
       ***********************************************************************/

      case state_type_id_waitforinput:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitforinput, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_waitforinput)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case sig_type_id_ip_packet:
              sigparam_ip_packet = (SigParam_ip_packet *)RetrieveInputData();
              assert(sigparam_ip_packet);
              v_ip_in = sigparam_ip_packet->sig_field_1;
              delete sigparam_ip_packet;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitforinput'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): tcp_packet
            sendpacket(v_tcp_in);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): ip_packet
            deliver(v_ip_in);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitforinput': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      default:
        std::cerr << "Process 'activity': Invalid process state." <<
                     std::endl;
        break;
    }
  }
}

/******************************************************************************
 * Save-Methode zur Speicherung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_ip_activity::Save(SCMem &save_area) const
{
  /****************************************************************************
   * Speicherung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Save(save_area);

  /****************************************************************************
   * Sicherung der Variablen:
   ***************************************************************************/

  v_tcp_in.Save(save_area);
  v_ip_in.Save(save_area);

  /****************************************************************************
   * Speicherung der Zustandsvariablen
   ***************************************************************************/

  save_area.Store(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_ip_activity::Restore(SCMem &save_area)
{
  /****************************************************************************
   * Restaurierung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Restore(save_area);

  /****************************************************************************
   * Restaurierung der Variablen:
   ***************************************************************************/

  v_tcp_in.Restore(save_area);
  v_ip_in.Restore(save_area);

  /****************************************************************************
   * Restaurierung der Zustandsvariablen
   ***************************************************************************/

  save_area.Restore(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz
 *****************************************************************************/

void pcs_ip_activity::Size(SCSize *cur_size) const
{
  /****************************************************************************
   * Berechnung der Groesse der Basisklasse
   ***************************************************************************/

  SCProcess::Size(cur_size);

  /****************************************************************************
   * Berechnung der Variablengroessen:
   ***************************************************************************/

  v_tcp_in.Size(cur_size);
  v_ip_in.Size(cur_size);

  /****************************************************************************
   * Groesse der Zustandsvariablen
   ***************************************************************************/

  cur_size->size += sizeof(v_cur_state);

}

/******************************************************************************
 * Display-Methode
 *****************************************************************************/

SCStream& operator<<(SCStream &out, const pcs_ip_activity &me)
{
  return me.Display(out);
}
