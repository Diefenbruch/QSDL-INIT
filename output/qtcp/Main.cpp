/******************************************************************************
 *                            Main.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "sys_qtcp.h"

#include <SCL/SCIndetSim.h>
#include <SCL/SCBitState.h>
#include <SCL/SCFullState.h>
#include <SCL/SCIndetVal.h>
#include <SCL/SCThreadTypes.h>
#include <SCL/SCMainThreadTypes.h>
#include <SCL/SCScheduler.h>
#include <SCL/SCSocket.h>

/******************************************************************************
 * Variablen zur Speicherung der Laufzeitoptionen
 *****************************************************************************/

SCTime run_time = 0.0;
SCIndet *indet = NULL;
SCSocket *sensor_socket = NULL;
char indet_name[80] = "";
char search_name[80] = "";
char formula[256] = "";
SCIndetType indet_type = scIndetSimulation;
SCStateSpaceType search_type = scBitStateSpace;
SCBoolean verbose = false;
SCBoolean fair = false;
SCBoolean find_errors = false;
SCNatural num_errors = 0;
SCBoolean find_dead_code = false;
SCBoolean find_loop = false;
SCNatural hash_table_power = kSCHashTablePower;
SCNatural hash_function_index = kSCHashFunctionIndex;
SCNatural max_depth = kSCMaxDepth;
SCBoolean msc_tracing = false;
SCBoolean socket_tracing = false;
SCBoolean pev_tracing = false;
char trace_file_name[MAX_PATH] = "Output.mpr";
char config_file_name[MAX_PATH] = "qtcp.pev";
SCReal display_rate = 1.0;
char host_name[64] = "";
SCNatural port_number = 20000;

/******************************************************************************
 * Funktion gibt eine Hilfemeldung auf dem Bildschirm aus
 *****************************************************************************/

static void PrintHelp(void)
{
  std::cout << "Available Options:" << std::endl;
  std::cout << "  -h                  : Display this help." <<
               std::endl;
  std::cout << "  -v                  : Verbose message output." <<
               std::endl;
  std::cout << "  -f                  : Fair progress of all instances." <<
               std::endl;
  std::cout << "  -e <num>            : Report functional errors (num = num of errors)." <<
               std::endl;
  std::cout << "  -u                  : Report dead code." <<
               std::endl;
  std::cout << "  -l                  : Loop detection." << std::endl;
  std::cout << "  -d <num>            : Max. depth of analysis (default: unlimited)." <<
               std::endl;
  std::cout << "  -y <char>           : Analysis type (s = simulation" <<
               std::endl;
  std::cout << "                                       r = reachability analysis)." <<
               std::endl;
  std::cout << "  -s <text>           : Search type ('bs' = bit state space" <<
               std::endl;
  std::cout << "                                     'fs' = full state space)." <<
               std::endl;
  std::cout << "  -p <num>            : Size of hash table (2^<num>, default: 16) (not with -y s)." <<
               std::endl;
  std::cout << "  -i <num>            : Index of hash function (1-5, default: 1) (not with -y s)." <<
               std::endl;
  std::cout << "  -m <text>           : Hostname for tracing or sensor display." <<
               std::endl;
  std::cout << "  -n                  : Portnumber for tracing or sensor display." <<
               std::endl;
  std::cout << "  -z <time>           : Max. modell time." <<
               std::endl;
  std::cout << "  -t <msc|socket|pev> : Enable tracing." << std::endl;
  std::cout << "  -o <file>           : Name of MSC trace file." <<
               std::endl;
  std::cout << "  -x <rate>           : Display rate for PEV." <<
               std::endl;
  std::cout << "  -c <file>           : Name of experiment file for PEV." <<
               std::endl;
  std::cout << std::endl;
  std::cout << "Example:" << std::endl;
  std::cout << "  qtcp -vy s -t pev -x 14 -c Test.pev" << std::endl;
}

/******************************************************************************
 * Funktion gibt die Copyrightmeldung zur Laufzeit aus
 *****************************************************************************/

static void PrintMessage(void)
{
  std::cout << std::endl << "*********************************************" <<
               std::endl;
  std::cout << "* QSDL-Evaluator                            *" <<
               std::endl;
  std::cout << "*                                           *" <<
               std::endl;
  std::cout << "* Version 1.5.0                             *" <<
               std::endl;
  std::cout << "*                                           *" <<
               std::endl;
  std::cout << "* Copyright (C) 1995-98 Marc Diefenbruch    *" <<
               std::endl;
  std::cout << "*                   and Wolfgang Textor     *" <<
               std::endl;
  std::cout << "*                   and Axel Hirche         *" <<
               std::endl;
  std::cout << "*                                           *" <<
               std::endl;
  std::cout << "* University of Essen, Germany              *" <<
               std::endl;
  std::cout << "*                                           *" <<
               std::endl;
  std::cout << "* All rights reserved                       *" <<
               std::endl;
  std::cout << "*                                           *" <<
               std::endl;
  std::cout << "* Bug reports: qsdl@informatik.uni-essen.de *" <<
               std::endl;
  std::cout << "*********************************************" <<
               std::endl << std::endl;
}

/******************************************************************************
 * Funktion parst die Laufzeitoptionen des Evaluators
 *****************************************************************************/

static int ParseOptions (int *argc, char **argv)
{
  unsigned int ci, errs = 0;
  int ai;
  int new_argc = 1;
  char trace_type_name[80];

  for (ai = 1;
       ai < *argc;
       ai++)
  {
    if (argv[ai][0] == '-')
    {
      for (ci = 1;
           ci < strlen(argv[ai]);
           ci++)
      {
        switch(argv[ai][ci])
        {
  
          case 'h':
            PrintHelp();
            exit(0);
            break;

          case 'v':
            verbose = true;
            break;

          case 'y': 
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(indet_name, &(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Analysis type is missing after -y" <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(indet_name, argv[++ai]);
            }
            if (!strcasecmp(indet_name, "s"))
            {
              indet_type = scIndetSimulation;
            }
            else if (!strcasecmp(indet_name, "r"))
            {
              indet_type = scIndetValidation;
            }
            else
            {
            std::cerr << "Unknown analysis type." << std::endl <<
                           std::endl;
            }
            ci = strlen(argv[ai]);
            break;

          case 'f':
            fair = true;
            break;

          case 'e': 
            find_errors = true;
            if (ci < strlen(argv[ai]) - 1)
            {
              num_errors = atoi(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Num of errors is missing after -e " <<
                             std::endl << std::endl;
                return -1;
              }
              num_errors = atoi(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 's': 
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(search_name, &(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Search type is missing after -s" <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(search_name, argv[++ai]);
            }
            if (!strcasecmp(search_name, "bs"))
            {
              search_type = scBitStateSpace;
            }
            else if (!strcasecmp(search_name, "fs"))
            {
              search_type = scFullStateSpace;
            }
            else
            {
            std::cerr << "Unknown search type." << std::endl <<
                           std::endl;
            }
            ci = strlen(argv[ai]);
            break;

          case 'u':
            find_dead_code = true;
            break;

          case 'l':
            find_loop = true;
            break;

          case 'p': 
            if (ci < strlen(argv[ai]) - 1)
            {
              hash_table_power = atoi(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Hash table power is missing after -p" <<
                             std::endl << std::endl;
                return -1;
              }
              hash_table_power = atoi(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'i': 
            if (ci < strlen(argv[ai]) - 1)
            {
              hash_function_index = atoi(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Hash function index is missing after -i" <<
                             std::endl << std::endl;
                return -1;
              }
              hash_function_index = atoi(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'r': 
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(formula, &(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Temporal formula is missing after -r " <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(formula, argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'd': 
            if (ci < strlen(argv[ai]) - 1)
            {
              max_depth = atoi(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Validation depth is missing after -d" <<
                             std::endl << std::endl;
                return -1;
              }
              max_depth = atoi(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 't':
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(trace_type_name, &(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cerr << "Trace type is missing after -t." <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(trace_type_name, argv[++ai]);
            }
            if (!strcasecmp(trace_type_name, "msc"))
            {
              msc_tracing = true;
            }
            else if (!strcasecmp(trace_type_name, "socket"))
            {
              socket_tracing = true;
            }
            else if (!strcasecmp(trace_type_name, "pev"))
            {
              pev_tracing = true;
            }
            else
            {
              std::cerr << "Unknown trace type." << std::endl <<
                           std::endl;
            }
            ci = strlen(argv[ai]);
            break;

          case 'o':
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(trace_file_name, &(argv[ai][ci + 1]));
            }
            else 
            { 
              if (ai + 1 == *argc)
              {
                std::cout << "Filename is missing after -o" <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(trace_file_name, argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'c': 
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(config_file_name, &(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Config file name is missing after -c" <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(config_file_name, argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'x': 
            if (ci < strlen(argv[ai]) - 1)
            {
              display_rate = atof(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Display rate is missing after -x" <<
                             std::endl << std::endl;
                return -1;
              }
              display_rate = atof(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'n': 
            if (ci < strlen(argv[ai]) - 1)
            {
              port_number = atoi(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Port number is missing" << std::endl <<
                             std::endl;
                return -1;
              }
              port_number = atoi(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'm':
            if (ci < strlen(argv[ai]) - 1)
            {
              strcpy(host_name, &(argv[ai][ci + 1]));
            }
            else 
            { 
              if (ai + 1 == *argc)
              {
                std::cout << "Hostname is missing after -m" <<
                             std::endl << std::endl;
                return -1;
              }
              strcpy(host_name, argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          case 'z': 
            if (ci < strlen(argv[ai]) - 1)
            {
              run_time = atof(&(argv[ai][ci + 1]));
            }
            else
            {
              if (ai + 1 == *argc)
              {
                std::cout << "Max. modell time is missing" <<
                             std::endl << std::endl;
                return -1;
              }
              run_time = atof(argv[++ai]);
            }
            ci = strlen(argv[ai]);
            break;

          default:
            std::cerr << "Unknown option '" << argv[ai][ci] <<
                         "' !" << std::endl;
            errs++;
            break;
        }
      }
    }
    else
    {
      argv[new_argc] = argv[ai];
      new_argc++;
    }
  }
  *argc = new_argc;
  if (errs > 0)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

/******************************************************************************
 * Hauptfunktion des Evaluators
 *****************************************************************************/

int main(int argc, char *argv[])
{
  SCStateSpace * state_space = NULL;
  SCStateSpace * cycle_state_space = NULL;

  PrintMessage();

  /****************************************************************************
   * Laufzeitoptionen parsen:
   ***************************************************************************/

  if (ParseOptions(&argc, argv) != 1)
  {
    PrintHelp();
    exit(-1);
  }

  switch (indet_type)
  {
    case scIndetValidation:
      switch (search_type)
      {
        case scBitStateSpace:
        default:
          state_space = new SCBitState(hash_table_power, hash_function_index);
          break;
        case scFullStateSpace:
          state_space = new SCFullState(hash_table_power, hash_function_index);
          break;
      }
      assert(state_space);
      if (find_loop)
      {
        switch (search_type)
        {
          case scBitStateSpace:
          default:
            cycle_state_space = new SCBitState(hash_table_power,
                                               hash_function_index);
            break;
          case scFullStateSpace:
            cycle_state_space = new SCFullState(hash_table_power,
                                                hash_function_index);
            break;
        }
        assert(cycle_state_space);
      }
      indet = new SCIndetVal(run_time, find_errors, num_errors,
                             find_dead_code, find_loop, state_space,
                             cycle_state_space, max_depth, kSCMaxCreatedInstances);
      assert(indet);
      break;
    case scIndetSimulation:
      indet = new SCIndetSim(run_time, find_errors, num_errors,
                             find_dead_code, max_depth);
      assert(indet);
      break;
    default:
      std::cerr << std::endl << "Illegal indet type!" << std::endl;
      exit(-1);
  }

  /****************************************************************************
   * Socket initialisieren:
   ***************************************************************************/

  if (host_name[0] != '\0')
  {
    sensor_socket = new SCSocket(host_name, port_number);
    assert(sensor_socket);
  }

  /****************************************************************************
   * Betriebssystem-Threads initialisieren:
   ***************************************************************************/

  if (verbose) std::cout << "Initializing system threads..." <<
                            std::endl;
  SCSystemThread::Initialize();

  /****************************************************************************
   * Main-Thread-Struktur initialisieren:
   ***************************************************************************/

  if (verbose) std::cout << "Initializing main thread..." << std::endl;
  SCMainThread::Initialize();

  /****************************************************************************
   * Laufzeitsystem initialisieren:
   ***************************************************************************/

  if (sys_qtcp::Initialize(indet, sensor_socket, fair, verbose,
                           msc_tracing, socket_tracing, pev_tracing,
                           trace_file_name, host_name, port_number,
                           config_file_name, display_rate))
  {
    /**************************************************************************
     * Evaluator starten:
     *************************************************************************/

    indet->StartMessage();
    SCScheduler::Run();
    indet->EndMessage();
  }

  /****************************************************************************
   * Laufzeitsystem beenden:
   ***************************************************************************/

  if (verbose) std::cout << "Finishing..." << std::endl;
  sys_qtcp::Finish();
  SCScheduler::Finish();
  SCMainThread::Finish();

  return 0;
}
