/******************************************************************************
 *                            pcs_tcp_port.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"
#include "pcs_tcp_manager.h"
#include "pcs_tcp_port.h"


#include <SCL/SCScheduler.h>
#include <SCL/SCTransition.h>

/******************************************************************************
 * Signaltypen der SDL-Timer auf Prozessebene (statisch)
 *****************************************************************************/

pcs_tcp_port::TimType_retr_timer * pcs_tcp_port_data::tim_type_retr_timer = NULL;
SCTimerType * pcs_tcp_port_data::tim_type_to_timer = NULL;
SCTimerType * pcs_tcp_port_data::tim_type_rcv_timer = NULL;
SCTimerType * pcs_tcp_port_data::tim_type_accept_timer = NULL;
SCTimerType * pcs_tcp_port_data::tim_type_create_packet_timer = NULL;

/******************************************************************************
 * Konstanten (Synonyme) auf Prozessebene (statisch)
 *****************************************************************************/

SCInteger pcs_tcp_port_data::syn_no_data;
SCInteger pcs_tcp_port_data::syn_unspecified_dp;
SCInteger pcs_tcp_port_data::syn_unspecified_da;
SCInteger pcs_tcp_port_data::syn_reset_error;

/******************************************************************************
 * Typen der SDL-Zustaende auf Prozessebene (statisch)
 *****************************************************************************/

SCStateType * pcs_tcp_port::state_type_start = NULL;
SCStateType * pcs_tcp_port::state_type_closed = NULL;
SCStateType * pcs_tcp_port::state_type_listen = NULL;
SCStateType * pcs_tcp_port::state_type_synreceived = NULL;
SCStateType * pcs_tcp_port::state_type_synsent = NULL;
SCStateType * pcs_tcp_port::state_type_established = NULL;
SCStateType * pcs_tcp_port::state_type_finwait1 = NULL;
SCStateType * pcs_tcp_port::state_type_finwait2 = NULL;
SCStateType * pcs_tcp_port::state_type_closing = NULL;
SCStateType * pcs_tcp_port::state_type_closewait = NULL;
SCStateType * pcs_tcp_port::state_type_lastack = NULL;
SCStateType * pcs_tcp_port::state_type_timewait = NULL;

/******************************************************************************
 * Input-Sets der Prozesstransitionen (statisch)
 *****************************************************************************/

SCSignalID pcs_tcp_port::input_set_closed_transition0[] =
{
  sig_type_id_upo
};
SCSignalID pcs_tcp_port::input_set_closed_transition1[] =
{
  sig_type_id_fspo
};
SCSignalID pcs_tcp_port::input_set_closed_transition2[] =
{
  sig_type_id_ao
};
SCSignalID pcs_tcp_port::input_set_closed_transition3[] =
{
  sig_type_id_aod
};
SCSignalID pcs_tcp_port::input_set_closed_transition4[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_listen_transition0[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_port::input_set_listen_transition1[] =
{
  sig_type_id_ao
};
SCSignalID pcs_tcp_port::input_set_listen_transition2[] =
{
  sig_type_id_aod
};
SCSignalID pcs_tcp_port::input_set_listen_transition3[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_synreceived_transition0[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_port::input_set_synreceived_transition1[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_synreceived_transition2[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_synreceived_transition3[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_synsent_transition0[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_port::input_set_synsent_transition1[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_synsent_transition2[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_synsent_transition3[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_established_transition0[] =
{
  sig_type_id_send
};
SCSignalID pcs_tcp_port::input_set_established_transition1[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_established_transition2[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_port::input_set_established_transition3[] =
{
  sig_type_id_abort
};
SCSignalID pcs_tcp_port::input_set_established_transition4[] =
{
  sig_type_id_status
};
SCSignalID pcs_tcp_port::input_set_established_transition5[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_established_transition6[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_established_transition7[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_finwait1_transition0[] =
{
  sig_type_id_send
};
SCSignalID pcs_tcp_port::input_set_finwait1_transition1[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_finwait1_transition2[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_finwait1_transition3[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_finwait1_transition4[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_finwait2_transition0[] =
{
  sig_type_id_send
};
SCSignalID pcs_tcp_port::input_set_finwait2_transition1[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_finwait2_transition2[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_finwait2_transition3[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_finwait2_transition4[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_closing_transition0[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_closing_transition1[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_closing_transition2[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_closing_transition3[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_closewait_transition0[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_closewait_transition1[] =
{
  tim_type_id_to_timer
};
SCSignalID pcs_tcp_port::input_set_closewait_transition2[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_closewait_transition3[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_closewait_transition4[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_port::input_set_closewait_transition5[] =
{
  sig_type_id_send
};
SCSignalID pcs_tcp_port::input_set_closewait_transition6[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_lastack_transition0[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_port::input_set_lastack_transition1[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_port::input_set_lastack_transition2[] =
{
  tim_type_id_retr_timer
};
SCSignalID pcs_tcp_port::input_set_lastack_transition3[] =
{
  tim_type_id_rcv_timer
};
SCSignalID pcs_tcp_port::input_set_timewait_transition0[] =
{
  tim_type_id_to_timer
};
SCSignalID pcs_tcp_port::input_set_timewait_transition1[] =
{
  sig_type_id_status, 
  sig_type_id_close, 
  sig_type_id_abort, 
  sig_type_id_upo, 
  sig_type_id_fspo, 
  sig_type_id_ao, 
  sig_type_id_aod, 
  sig_type_id_send, 
  sig_type_id_allocate, 
  sig_type_id_tcp_packet, 
  tim_type_id_retr_timer
};

/******************************************************************************
 * Initialisierungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

SCBoolean pcs_tcp_port_data::Initialize(void)
{
  SCBoolean result = true;

  if (SCScheduler::IsVerbose())
  {
    SCScheduler::outputStream << "Initializing process port..." << std::endl;
  }

  /****************************************************************************
   * Datentypen auf Prozessebene initialisieren:
   ***************************************************************************/

  syn_no_data = 0;
  syn_unspecified_dp =  -1;
  syn_unspecified_da =  -1;
  syn_reset_error = 0;

  /****************************************************************************
   * Timertypen der SDL-Timer initialisieren:
   ***************************************************************************/

  tim_type_retr_timer = new TimType_retr_timer(tim_type_id_retr_timer,
                                               "retr_timer");
  tim_type_to_timer = new SCTimerType(tim_type_id_to_timer, "to_timer");
  tim_type_rcv_timer = new SCTimerType(tim_type_id_rcv_timer,
                                       "rcv_timer");
  tim_type_accept_timer = new SCTimerType(tim_type_id_accept_timer,
                                          "accept_timer");
  tim_type_create_packet_timer = new SCTimerType(tim_type_id_create_packet_timer,
                                                 "create_packet_timer");


  return result;
}

SCBoolean pcs_tcp_port::Initialize(void)
{
  SCTransition *v_transition;
  SCBoolean result = true;

  /****************************************************************************
   * Initialisierung aller Zustaende des Prozesstyps:
   ***************************************************************************/

  state_type_start = new SCStateType(state_type_id_start, "start");
  state_type_closed = new SCStateType(state_type_id_closed, "closed", 0, NULL, false, false, pcs_type_port);
  state_type_listen = new SCStateType(state_type_id_listen, "listen", 0, NULL, false, false, pcs_type_port);
  state_type_synreceived = new SCStateType(state_type_id_synreceived,
                                           "synreceived", 0,
                                           NULL, false, false,
                                           pcs_type_port);
  state_type_synsent = new SCStateType(state_type_id_synsent,
                                       "synsent", 0, NULL, false,
                                       false, pcs_type_port);
  state_type_established = new SCStateType(state_type_id_established,
                                           "established", 0,
                                           NULL, false, false,
                                           pcs_type_port);
  state_type_finwait1 = new SCStateType(state_type_id_finwait1,
                                        "finwait1", 0, NULL,
                                        false, false, pcs_type_port);
  state_type_finwait2 = new SCStateType(state_type_id_finwait2,
                                        "finwait2", 0, NULL,
                                        false, false, pcs_type_port);
  state_type_closing = new SCStateType(state_type_id_closing,
                                       "closing", 0, NULL, false,
                                       false, pcs_type_port);
  state_type_closewait = new SCStateType(state_type_id_closewait,
                                         "closewait", 0, NULL,
                                         false, false, pcs_type_port);
  state_type_lastack = new SCStateType(state_type_id_lastack,
                                       "lastack", 0, NULL, false,
                                       false, pcs_type_port);
  state_type_timewait = new SCStateType(state_type_id_timewait,
                                        "timewait", 0, NULL,
                                        false, false, pcs_type_port);

  /****************************************************************************
   * Initialisierung aller Transitionen des Prozesstyps:
   ***************************************************************************/

  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_start,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_closed,
                                  sizeof(input_set_closed_transition0) / sizeof(SCSignalID),
                                  input_set_closed_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_closed,
                                  sizeof(input_set_closed_transition1) / sizeof(SCSignalID),
                                  input_set_closed_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_closed,
                                  sizeof(input_set_closed_transition2) / sizeof(SCSignalID),
                                  input_set_closed_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_closed,
                                  sizeof(input_set_closed_transition3) / sizeof(SCSignalID),
                                  input_set_closed_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_closed,
                                  sizeof(input_set_closed_transition4) / sizeof(SCSignalID),
                                  input_set_closed_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_listen,
                                  sizeof(input_set_listen_transition0) / sizeof(SCSignalID),
                                  input_set_listen_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_listen,
                                  sizeof(input_set_listen_transition1) / sizeof(SCSignalID),
                                  input_set_listen_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_listen,
                                  sizeof(input_set_listen_transition2) / sizeof(SCSignalID),
                                  input_set_listen_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_listen,
                                  sizeof(input_set_listen_transition3) / sizeof(SCSignalID),
                                  input_set_listen_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_synreceived,
                                  sizeof(input_set_synreceived_transition0) / sizeof(SCSignalID),
                                  input_set_synreceived_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_synreceived,
                                  sizeof(input_set_synreceived_transition1) / sizeof(SCSignalID),
                                  input_set_synreceived_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_synreceived,
                                  sizeof(input_set_synreceived_transition2) / sizeof(SCSignalID),
                                  input_set_synreceived_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_synreceived,
                                  sizeof(input_set_synreceived_transition3) / sizeof(SCSignalID),
                                  input_set_synreceived_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_synsent,
                                  sizeof(input_set_synsent_transition0) / sizeof(SCSignalID),
                                  input_set_synsent_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_synsent,
                                  sizeof(input_set_synsent_transition1) / sizeof(SCSignalID),
                                  input_set_synsent_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_synsent,
                                  sizeof(input_set_synsent_transition2) / sizeof(SCSignalID),
                                  input_set_synsent_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_synsent,
                                  sizeof(input_set_synsent_transition3) / sizeof(SCSignalID),
                                  input_set_synsent_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_established,
                                  sizeof(input_set_established_transition0) / sizeof(SCSignalID),
                                  input_set_established_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_established,
                                  sizeof(input_set_established_transition1) / sizeof(SCSignalID),
                                  input_set_established_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_established,
                                  sizeof(input_set_established_transition2) / sizeof(SCSignalID),
                                  input_set_established_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_established,
                                  sizeof(input_set_established_transition3) / sizeof(SCSignalID),
                                  input_set_established_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_established,
                                  sizeof(input_set_established_transition4) / sizeof(SCSignalID),
                                  input_set_established_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 5, state_type_established,
                                  sizeof(input_set_established_transition5) / sizeof(SCSignalID),
                                  input_set_established_transition5,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 6, state_type_established,
                                  sizeof(input_set_established_transition6) / sizeof(SCSignalID),
                                  input_set_established_transition6,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 7, state_type_established,
                                  sizeof(input_set_established_transition7) / sizeof(SCSignalID),
                                  input_set_established_transition7,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_finwait1,
                                  sizeof(input_set_finwait1_transition0) / sizeof(SCSignalID),
                                  input_set_finwait1_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_finwait1,
                                  sizeof(input_set_finwait1_transition1) / sizeof(SCSignalID),
                                  input_set_finwait1_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_finwait1,
                                  sizeof(input_set_finwait1_transition2) / sizeof(SCSignalID),
                                  input_set_finwait1_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_finwait1,
                                  sizeof(input_set_finwait1_transition3) / sizeof(SCSignalID),
                                  input_set_finwait1_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_finwait1,
                                  sizeof(input_set_finwait1_transition4) / sizeof(SCSignalID),
                                  input_set_finwait1_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_finwait2,
                                  sizeof(input_set_finwait2_transition0) / sizeof(SCSignalID),
                                  input_set_finwait2_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_finwait2,
                                  sizeof(input_set_finwait2_transition1) / sizeof(SCSignalID),
                                  input_set_finwait2_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_finwait2,
                                  sizeof(input_set_finwait2_transition2) / sizeof(SCSignalID),
                                  input_set_finwait2_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_finwait2,
                                  sizeof(input_set_finwait2_transition3) / sizeof(SCSignalID),
                                  input_set_finwait2_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_finwait2,
                                  sizeof(input_set_finwait2_transition4) / sizeof(SCSignalID),
                                  input_set_finwait2_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_closing,
                                  sizeof(input_set_closing_transition0) / sizeof(SCSignalID),
                                  input_set_closing_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_closing,
                                  sizeof(input_set_closing_transition1) / sizeof(SCSignalID),
                                  input_set_closing_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_closing,
                                  sizeof(input_set_closing_transition2) / sizeof(SCSignalID),
                                  input_set_closing_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_closing,
                                  sizeof(input_set_closing_transition3) / sizeof(SCSignalID),
                                  input_set_closing_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_closewait,
                                  sizeof(input_set_closewait_transition0) / sizeof(SCSignalID),
                                  input_set_closewait_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_closewait,
                                  sizeof(input_set_closewait_transition1) / sizeof(SCSignalID),
                                  input_set_closewait_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_closewait,
                                  sizeof(input_set_closewait_transition2) / sizeof(SCSignalID),
                                  input_set_closewait_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_closewait,
                                  sizeof(input_set_closewait_transition3) / sizeof(SCSignalID),
                                  input_set_closewait_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_closewait,
                                  sizeof(input_set_closewait_transition4) / sizeof(SCSignalID),
                                  input_set_closewait_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 5, state_type_closewait,
                                  sizeof(input_set_closewait_transition5) / sizeof(SCSignalID),
                                  input_set_closewait_transition5,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 6, state_type_closewait,
                                  sizeof(input_set_closewait_transition6) / sizeof(SCSignalID),
                                  input_set_closewait_transition6,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_lastack,
                                  sizeof(input_set_lastack_transition0) / sizeof(SCSignalID),
                                  input_set_lastack_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_lastack,
                                  sizeof(input_set_lastack_transition1) / sizeof(SCSignalID),
                                  input_set_lastack_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_lastack,
                                  sizeof(input_set_lastack_transition2) / sizeof(SCSignalID),
                                  input_set_lastack_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_lastack,
                                  sizeof(input_set_lastack_transition3) / sizeof(SCSignalID),
                                  input_set_lastack_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_timewait,
                                  sizeof(input_set_timewait_transition0) / sizeof(SCSignalID),
                                  input_set_timewait_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_timewait,
                                  sizeof(input_set_timewait_transition1) / sizeof(SCSignalID),
                                  input_set_timewait_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

void pcs_tcp_port_data::Finish(void)
{
  /****************************************************************************
   * Timertypen der SDL-Timer zerstoeren:
   ***************************************************************************/

  delete tim_type_retr_timer;
  delete tim_type_to_timer;
  delete tim_type_rcv_timer;
  delete tim_type_accept_timer;
  delete tim_type_create_packet_timer;

}

void pcs_tcp_port::Finish(void)
{
  /****************************************************************************
   * Zustandstypen der Prozess-Zustaende zerstoeren:
   ***************************************************************************/

  delete state_type_start;
  delete state_type_closed;
  delete state_type_listen;
  delete state_type_synreceived;
  delete state_type_synsent;
  delete state_type_established;
  delete state_type_finwait1;
  delete state_type_finwait2;
  delete state_type_closing;
  delete state_type_closewait;
  delete state_type_lastack;
  delete state_type_timewait;

}

/******************************************************************************
 * Konstruktoren
 *****************************************************************************/

pcs_tcp_port_data::pcs_tcp_port_data(void)
{
}

pcs_tcp_port::pcs_tcp_port(const SCProcessID creator, const SCProcessType *proc_type) : 
  SCProcess(creator, proc_type, state_type_start, NULL, false)
{
#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Creating " << *this << std::endl;
  }

  /****************************************************************************
   * Variableninitialisierung:
   ***************************************************************************/

  v_po = false;
  v_ok = false;
  v_psh = false;
  v_urg = false;
  v_close_connection = false;
  v_close_received = false;
  v_fin_tmp = false;
  v_oldest = 0;
  v_sp = 0;
  v_tout = 0;
  v_toa = 0;
  v_prec = 0;
  v_sec = 0;
  v_len = 0;
  v_da = 0;
  v_dp = 0;
  v_rbuffer = 0;

  /****************************************************************************
   * Aktuellen Zustand auf Startzustand setzen:
   ***************************************************************************/

  v_cur_state = state_type_id_start;

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

pcs_tcp_port::pcs_tcp_port(SCMem &save_area) : 
  SCProcess(false, (SCObject *)NULL)
{
  Restore(save_area);

#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Recreated " << *this << std::endl;
  }

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

pcs_tcp_port_data::~pcs_tcp_port_data(void)
{
}

pcs_tcp_port::~pcs_tcp_port(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Deleting " << *this << std::endl;
  }
}

/******************************************************************************
 * Lokale Prozeduren
 *****************************************************************************/

void pcs_tcp_port::sendroutine(SCInteger v_len, SCInteger v_seq,
                               SCBoolean v_ack, SCBoolean v_syn,
                               SCBoolean v_urg, SCBoolean v_psh,
                               SCBoolean v_rst, SCBoolean v_fin)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_tcp v_tcp_out;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_tcb.field_snd_wnd < v_len)
  {
    case true:
      return;
      break;
    case false:
      break;
  }
  v_tcp_out.field_sp = v_tcb.field_sp;
  v_tcp_out.field_dp = v_tcb.field_dp;
  v_tcp_out.field_da = v_tcb.field_da;
  v_tcp_out.field_len = v_len;
  v_tcp_out.field_cs = v_len;
  v_tcp_out.field_urg = v_urg;
  v_tcp_out.field_ack = v_ack;
  v_tcp_out.field_syn = v_syn;
  v_tcp_out.field_psh = v_psh;
  v_tcp_out.field_rst = v_rst;
  v_tcp_out.field_fin = v_fin;
  v_tcp_out.field_an = v_tcb.field_rcv_nxt;
  v_tcp_out.field_seq = v_seq;
  v_tcp_out.field_wnd = syn_window_size;
  v_tcp_out.field_sa = 0;
  v_tcp_out.field_urgp = 0;
  switch (v_urg)
  {
    case true:
      v_tcp_out.field_urgp = v_len;
      break;
    case false:
      break;
  }
  v_tcb.field_snd_wnd = v_tcb.field_snd_wnd - v_len;
  v_tcb.field_snd_nxt = (v_tcb.field_snd_nxt + v_len) % syn_maxnr;
  addretransmit(v_tcp_out);
  sigparam_tcp_packet = new SigParam_tcp_packet;
  assert(sigparam_tcp_packet);
  sigparam_tcp_packet->sig_field_1 = v_tcp_out;
  Output(Parent(), sig_type_tcp_packet, sigparam_tcp_packet);
  deliverdata();
  v_trace_block.field_packetoutput = v_trace_block.field_packetoutput + 1;
  SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
  return;
}

void pcs_tcp_port::datarequest(SCInteger v_len, SCBoolean v_ack,
                               SCBoolean v_syn, SCBoolean v_urg,
                               SCBoolean v_psh, SCBoolean v_rst,
                               SCBoolean v_fin)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  switch (v_fin)
  {
    case true:
      switch ((v_send_data.field_len <= syn_standard) && (v_tcb.field_snd_wnd >= v_send_data.field_len))
      {
        case true:
          break;
        case false:
          v_fin = false;
          v_fin_tmp = true;
          break;
      }
      break;
    case false:
      break;
  }
  v_send_data.field_len = v_send_data.field_len + v_len;
  switch (v_urg)
  {
    case true:
      v_send_data.field_urg = true;
      v_send_data.field_urgp = v_send_data.field_len;
      break;
    case false:
      break;
  }
  switch (v_psh)
  {
    case true:
      v_send_data.field_psh = true;
      v_send_data.field_pshp = v_send_data.field_len;
      break;
    case false:
      break;
  }
  switch (v_send_data.field_psh)
  {
    case true:
      switch ((v_tcb.field_snd_wnd >= v_send_data.field_pshp) ||
              (v_tcb.field_snd_wnd >= syn_standard))
      {
        case true:
          switch ((v_send_data.field_len > syn_standard) &&
                  (v_tcb.field_snd_wnd >= syn_standard))
          {
            case true:
              switch (v_send_data.field_urgp > syn_standard)
              {
                case true:
                  v_send_data.field_urgp = v_send_data.field_urgp - syn_standard;
                  sendroutine(syn_standard, v_tcb.field_snd_nxt,
                              v_ack, v_syn, v_send_data.field_urg,
                              v_send_data.field_psh, v_rst,
                              v_fin);
                  break;
                case false:
                  sendroutine(syn_standard, v_tcb.field_snd_nxt,
                              v_ack, v_syn, v_send_data.field_urg,
                              v_send_data.field_psh, v_rst,
                              v_fin);
                  v_send_data.field_urgp = 0;
                  v_send_data.field_urg = false;
                  break;
              }
              v_send_data.field_len = v_send_data.field_len - syn_standard;
              switch (v_send_data.field_pshp > syn_standard)
              {
                case true:
                  v_send_data.field_pshp = v_send_data.field_pshp - syn_standard;
                  break;
                case false:
                  v_send_data.field_pshp = 0;
                  v_send_data.field_psh = false;
                  break;
              }
              v_len = 0;
              v_urg = v_send_data.field_urg;
              v_psh = v_send_data.field_psh;
              v_fin = v_fin_tmp;
              goto label_jump1;
              break;
            case false:
              switch (v_send_data.field_pshp <= v_tcb.field_snd_wnd)
              {
                case true:
                  sendroutine(v_send_data.field_pshp, v_tcb.field_snd_nxt,
                              v_ack, v_syn, v_send_data.field_urg,
                              v_send_data.field_psh, v_rst,
                              v_fin);
                  v_send_data.field_len = v_send_data.field_len - v_send_data.field_pshp;
                  v_send_data.field_pshp = 0;
                  v_send_data.field_psh = false;
                  v_send_data.field_urg = false;
                  v_send_data.field_urgp = 0;
                  break;
                case false:
                  break;
              }
              return;
              break;
          }
          break;
        case false:
          sendstandard();
          return;
          break;
      }
      break;
    case false:
      sendstandard();
      return;
      break;
  }
}

void pcs_tcp_port::resetrequest(SCInteger v_da, SCInteger v_dp,
                                SCInteger v_len, SCBoolean v_ack,
                                SCBoolean v_syn, SCBoolean v_urg,
                                SCBoolean v_psh, SCBoolean v_rst,
                                SCBoolean v_fin)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_tcp v_tcp_out;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  v_tcp_out.field_sp = v_tcb.field_sp;
  v_tcp_out.field_dp = v_dp;
  v_tcp_out.field_da = v_da;
  v_tcp_out.field_len = 0;
  v_tcp_out.field_cs = 0;
  v_tcp_out.field_urg = v_urg;
  v_tcp_out.field_ack = v_ack;
  v_tcp_out.field_syn = v_syn;
  v_tcp_out.field_psh = v_psh;
  v_tcp_out.field_rst = v_rst;
  v_tcp_out.field_fin = v_fin;
  v_tcp_out.field_an = v_tcb.field_rcv_nxt;
  v_tcp_out.field_seq = v_tcb.field_snd_nxt;
  v_tcp_out.field_wnd = v_tcb.field_rcv_wnd;
  v_len = 0;
  sigparam_tcp_packet = new SigParam_tcp_packet;
  assert(sigparam_tcp_packet);
  sigparam_tcp_packet->sig_field_1 = v_tcp_out;
  Output(Parent(), sig_type_tcp_packet, sigparam_tcp_packet);
  return;
}

void pcs_tcp_port::sendstandard(void)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  SCBoolean v_urg = false;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch ((v_send_data.field_len >= syn_standard) && (v_tcb.field_snd_wnd >= syn_standard))
  {
    case false:
      return;
      break;
    case true:
      switch (v_send_data.field_urg)
      {
        case true:
          v_urg = true;
          switch (v_send_data.field_urgp > syn_standard)
          {
            case true:
              v_send_data.field_urgp = v_send_data.field_urgp - syn_standard;
              break;
            case false:
              v_send_data.field_urgp = 0;
              v_send_data.field_urg = false;
              break;
          }
          break;
        case false:
          break;
      }
      sendroutine(syn_standard, v_tcb.field_snd_nxt, true, false,
                  v_urg, false, false, false);
      v_send_data.field_len = v_send_data.field_len - syn_standard;
      sendstandard();
      break;
  }
  return;
}

void pcs_tcp_port::addretransmit(DataType_tcp v_tcp_out)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_retransmitpacket v_new;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  v_n = v_oldest;
  getfreebuffer(v_n);
  v_new.field_tcp_packet.field_sp = v_tcp_out.field_sp;
  v_new.field_tcp_packet.field_dp = v_tcp_out.field_dp;
  v_new.field_tcp_packet.field_da = v_tcp_out.field_da;
  v_new.field_tcp_packet.field_len = v_tcp_out.field_len;
  v_new.field_tcp_packet.field_cs = v_tcp_out.field_cs;
  v_new.field_tcp_packet.field_syn = v_tcp_out.field_syn;
  v_new.field_tcp_packet.field_ack = v_tcp_out.field_ack;
  v_new.field_tcp_packet.field_psh = v_tcp_out.field_urg;
  v_new.field_tcp_packet.field_urgp = v_tcp_out.field_urgp;
  v_new.field_tcp_packet.field_fin = v_tcp_out.field_fin;
  v_new.field_tcp_packet.field_rst = v_tcp_out.field_rst;
  v_new.field_tcp_packet.field_wnd = v_tcp_out.field_wnd;
  v_new.field_tcp_packet.field_an = v_tcp_out.field_an;
  v_new.field_tcp_packet.field_seq = v_tcp_out.field_seq;
  v_new.field_failed_retransmit = 0;
  v_new.field_activ = true;
  v_retransmit_queue[v_n] = v_new;
  timparam_retr_timer = new TimParam_retr_timer;
  assert(timparam_retr_timer);
  timparam_retr_timer->tim_field_1 = v_n;
  SetTimer(Now() + syn_default_to, tim_type_retr_timer, timparam_retr_timer);
  return;
}

void pcs_tcp_port::getfreebuffer(DataType_retransmitrange &v_n)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_retransmitpacket v_new;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  v_new = v_retransmit_queue[v_n];
  switch (v_new.field_activ)
  {
    case true:
      v_n = (v_n + 1) % syn_buffer_size;
      goto label_jump1;
      break;
    case false:
      return;
      break;
  }
}

void pcs_tcp_port::sendretransmit(DataType_retransmitrange v_n)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_retransmitpacket v_new;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  v_new = v_retransmit_queue[v_n];
  switch (v_new.field_activ)
  {
    case true:
      v_new.field_failed_retransmit = v_new.field_failed_retransmit + 1;
      break;
    case false:
      v_ok = true;
      return;
      break;
  }
  switch (v_new.field_failed_retransmit > syn_max_retransmit)
  {
    case true:
      sigparam_closing = new SigParam_closing;
      assert(sigparam_closing);
      sigparam_closing->sig_field_1 = v_tcb.field_sp;
      Output(blk_tcp::pcs_type_manager, sig_type_closing, sigparam_closing);
      v_ok = false;
      return;
      break;
    case false:
      v_trace_block.field_retransmitted = v_trace_block.field_retransmitted + 1;
      v_new.field_failed_retransmit = v_new.field_failed_retransmit + 1;
      v_retransmit_queue[v_n] = v_new;
      sigparam_err = new SigParam_err;
      assert(sigparam_err);
      sigparam_err->sig_field_1 = v_tcb.field_sp;
      sigparam_err->sig_field_2 = syn_default_error;
      Output(Parent(), sig_type_err, sigparam_err);
      timparam_retr_timer = new TimParam_retr_timer;
      assert(timparam_retr_timer);
      timparam_retr_timer->tim_field_1 = v_n;
      SetTimer(Now() + syn_default_to, tim_type_retr_timer, timparam_retr_timer);
      switch (v_n == syn_buffer_size)
      {
        case true:
          v_n = 0;
          break;
        case false:
          v_n = v_n + 1;
          break;
      }
      goto label_jump1;
      break;
  }
  return;
}

void pcs_tcp_port::updateretransmit(DataType_tcp v_tcp_in)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_retransmitpacket v_old;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  v_old = v_retransmit_queue[v_oldest];
  switch (v_old.field_activ)
  {
    case false:
      v_oldest = 0;
      return;
      break;
    case true:
      break;
  }
  switch (((v_old.field_tcp_packet.field_seq + v_old.field_tcp_packet.field_len) <= v_tcp_in.field_an) ||
          (((v_old.field_tcp_packet.field_seq + v_old.field_tcp_packet.field_len) > v_tcp_in.field_an) &&
            (v_old.field_tcp_packet.field_seq > v_tcp_in.field_an)))
  {
    case true:
      timparam_retr_timer = new TimParam_retr_timer;
      assert(timparam_retr_timer);
      timparam_retr_timer->tim_field_1 = v_oldest;
      ResetTimer(tim_type_retr_timer, timparam_retr_timer);
      delete timparam_retr_timer;
      v_old.field_activ = false;
      v_retransmit_queue[v_oldest] = v_old;
      v_oldest = (v_oldest + 1) % syn_buffer_size;
      goto label_jump1;
      break;
    case false:
      break;
  }
  return;
}

void pcs_tcp_port::updatetcb(DataType_tcp v_tcp_in)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  SCInteger v_dispose = 0;
  SCInteger v_tmp = 0;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_tcb.field_snd_nxt >= v_tcp_in.field_an)
  {
    case true:
      v_dispose = v_tcb.field_snd_nxt - v_tcp_in.field_an;
      break;
    case false:
      v_dispose = (syn_maxnr - v_tcp_in.field_an) + v_tcb.field_snd_nxt;
      break;
  }
  v_tcb.field_snd_una = v_tcp_in.field_an;
  v_tmp = v_tcp_in.field_seq + v_tcp_in.field_len;
  v_tcb.field_snd_wnd = v_tcp_in.field_wnd - v_dispose;
  v_tcb.field_rcv_wnd = v_tcb.field_rcv_wnd - v_tcp_in.field_len;
  v_tcb.field_rcv_nxt = (v_tcp_in.field_seq + v_tcp_in.field_len) % syn_maxnr;
  return;
}

void pcs_tcp_port::acceptpacket(DataType_tcp v_tcp_in)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_tcb.field_dp ==  -1)
  {
    case true:
      v_tcb.field_dp = v_tcp_in.field_sp;
      v_tcb.field_da = v_tcp_in.field_sa;
      break;
    case false:
      break;
  }
  v_rec_data.field_len = v_rec_data.field_len + v_tcp_in.field_len;
  v_rec_data.field_fin = v_tcp_in.field_fin;
  updatetcb(v_tcp_in);
  switch (v_tcp_in.field_psh)
  {
    case true:
      v_rec_data.field_psh = true;
      v_rec_data.field_pshp = v_rec_data.field_len;
      break;
    case false:
      break;
  }
  switch (v_tcp_in.field_urg)
  {
    case true:
      v_rec_data.field_urg = true;
      v_rec_data.field_urgp = v_rec_data.field_len;
      break;
    case false:
      break;
  }
  updateretransmit(v_tcp_in);
  deliverdata();
  return;
}

void pcs_tcp_port::checkchecksum(DataType_tcp v_tcp_in, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_tcp_in.field_len == v_tcp_in.field_cs)
  {
    case true:
      v_ok = true;
      return;
      break;
    case false:
      v_ok = false;
      v_trace_block.field_bad_checksum = v_trace_block.field_bad_checksum + 1;
      return;
      break;
  }
}

void pcs_tcp_port::checksynpacket(DataType_tcp v_tcp_in, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (((v_tcp_in.field_seq == v_tcb.field_rcv_nxt) && v_tcp_in.field_ack) &&
          (v_tcp_in.field_an == v_tcb.field_snd_nxt))
  {
    case true:
      v_ok = true;
      return;
      break;
    case false:
      v_ok = false;
      return;
      break;
  }
}

void pcs_tcp_port::checksequence(DataType_tcp v_tcp_in, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (((((v_tcp_in.field_seq == v_tcb.field_rcv_nxt) &&
             (v_tcb.field_snd_nxt >= v_tcb.field_snd_una)) &&
            (v_tcp_in.field_an >= v_tcb.field_snd_una)) &&
           (v_tcp_in.field_an <= v_tcb.field_snd_nxt)) || (((v_tcp_in.field_seq == v_tcb.field_rcv_nxt) &&
                                                             (v_tcb.field_snd_nxt <= v_tcb.field_snd_una)) &&
                                                            ((v_tcp_in.field_an >= v_tcb.field_snd_una) ||
                                                              (v_tcp_in.field_an <= v_tcb.field_snd_nxt))))
  {
    case true:
      v_ok = true;
      return;
      break;
    case false:
      v_ok = false;
      sigparam_err = new SigParam_err;
      assert(sigparam_err);
      sigparam_err->sig_field_1 = v_tcb.field_sp;
      sigparam_err->sig_field_2 = syn_default_error;
      Output(Parent(), sig_type_err, sigparam_err);
      return;
      break;
  }
}

void pcs_tcp_port::isreset(DataType_tcp v_tcp_in, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  checksequence(v_tcp_in, v_ok);
  switch (v_tcp_in.field_rst && v_ok)
  {
    case true:
      v_ok = true;
      v_trace_block.field_is_reset = v_trace_block.field_is_reset + 1;
      sigparam_err = new SigParam_err;
      assert(sigparam_err);
      sigparam_err->sig_field_1 = v_tcb.field_sp;
      sigparam_err->sig_field_2 = syn_fatal_error;
      Output(Parent(), sig_type_err, sigparam_err);
      return;
      break;
    case false:
      v_ok = false;
      return;
      break;
  }
}

void pcs_tcp_port::initretransmitqueue(DataType_retransmitrange v_first)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  switch (v_first < syn_buffer_size)
  {
    case true:
      v_retransmit_queue[v_first].field_activ = false;
      v_retransmit_queue[v_first].field_tcp_packet.field_len = 0;
      v_retransmit_queue[v_first].field_tcp_packet.field_cs = 0;
      v_retransmit_queue[v_first].field_tcp_packet.field_syn = false;
      v_retransmit_queue[v_first].field_tcp_packet.field_ack = false;
      v_retransmit_queue[v_first].field_tcp_packet.field_fin = false;
      v_retransmit_queue[v_first].field_tcp_packet.field_rst = false;
      v_first = v_first + 1;
      goto label_jump1;
      break;
    case false:
      break;
  }
  return;
}

void pcs_tcp_port::init(SCInteger v_sp, SCInteger v_dp, SCInteger v_da,
                        SCInteger v_tout, SCInteger v_toa, SCInteger v_prec,
                        SCInteger v_sec, SCBoolean v_psh, SCBoolean v_urg)
{
  /****************************************************************************
   * Lokale Variablen der Prozedur:
   ***************************************************************************/

  DataType_retransmitrange v_first;

  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  v_tcb.field_sp = v_sp;
  v_tcb.field_dp = v_dp;
  v_tcb.field_da = v_da;
  v_tcb.field_tout = v_tout;
  v_tcb.field_toa = v_toa;
  v_tcb.field_prec = v_prec;
  v_tcb.field_sec = v_sec;
  v_tcb.field_psh = v_psh;
  v_tcb.field_urg = v_urg;
  v_tcb.field_snd_nxt = 0;
  v_tcb.field_isn = 0;
  v_oldest = 0;
  v_first = 0;
  v_tcb.field_snd_wnd = syn_standard;
  v_tcb.field_rcv_wnd = syn_window_size;
  v_rbuffer = 100 * syn_standard;
  v_tcb.field_snd_una = 0;
  v_close_connection = false;
  v_close_received = false;
  v_fin_tmp = false;
  v_rec_data.field_len = 0;
  v_rec_data.field_urgp = 0;
  v_rec_data.field_pshp = 0;
  v_rec_data.field_fin = false;
  v_rec_data.field_urg = false;
  v_rec_data.field_psh = false;
  v_send_data.field_len = 0;
  v_send_data.field_urgp = 0;
  v_send_data.field_pshp = 0;
  v_send_data.field_fin = false;
  v_send_data.field_urg = false;
  v_send_data.field_psh = false;
  initretransmitqueue(v_first);
  return;
}

void pcs_tcp_port::deliverdata(void)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_rec_data.field_len == 0)
  {
    case true:
      return;
      break;
    case false:
      switch (v_rbuffer >= v_rec_data.field_len)
      {
        case true:
          sigparam_del = new SigParam_del;
          assert(sigparam_del);
          sigparam_del->sig_field_1 = v_tcb.field_sp;
          sigparam_del->sig_field_2 = v_rec_data.field_len;
          sigparam_del->sig_field_3 = v_rec_data.field_urg;
          Output(Parent(), sig_type_del, sigparam_del);
          v_rbuffer = v_rbuffer - v_rec_data.field_len;
          v_tcb.field_rcv_wnd = v_tcb.field_rcv_wnd + v_rec_data.field_len;
          v_rec_data.field_urg = false;
          v_rec_data.field_psh = false;
          v_rec_data.field_urgp = 0;
          v_rec_data.field_pshp = 0;
          v_rec_data.field_len = 0;
          return;
          break;
        case false:
          switch (v_rec_data.field_psh && (v_rec_data.field_pshp <= v_rbuffer))
          {
            case true:
              sigparam_del = new SigParam_del;
              assert(sigparam_del);
              sigparam_del->sig_field_1 = v_tcb.field_sp;
              sigparam_del->sig_field_2 = v_rec_data.field_pshp;
              sigparam_del->sig_field_3 = true;
              Output(Parent(), sig_type_del, sigparam_del);
              switch (v_rec_data.field_urgp >= v_rec_data.field_pshp)
              {
                case true:
                  v_rec_data.field_urgp = v_rec_data.field_urgp - v_rec_data.field_pshp;
                  break;
                case false:
                  v_rec_data.field_urgp = 0;
                  v_rec_data.field_urg = false;
                  break;
              }
              v_rbuffer = v_rbuffer - v_rec_data.field_pshp;
              v_tcb.field_rcv_wnd = v_tcb.field_rcv_wnd + v_rec_data.field_pshp;
              v_rec_data.field_len = v_rec_data.field_len - v_rec_data.field_pshp;
              v_rec_data.field_psh = false;
              v_rec_data.field_pshp = 0;
              return;
              break;
            case false:
              break;
          }
          break;
      }
      break;
  }
  return;
}

void pcs_tcp_port::islastack(DataType_tcp v_tcp_in, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch ((v_tcp_in.field_an == v_tcb.field_snd_nxt) && v_tcp_in.field_ack)
  {
    case true:
      v_ok = true;
      break;
    case false:
      v_ok = false;
      break;
  }
  return;
}


/******************************************************************************
 * Implementierungsfunktion des SDL-Prozesses
 *****************************************************************************/

void pcs_tcp_port::Body(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Executing " << *this << std::endl;
  }

  /****************************************************************************
   * Hauptschleife:
   ***************************************************************************/

  nextstate:
  v_transition_id = kSCNoTransition;
  backtracking:
  while(true)
  {
    switch(v_cur_state)
    {
      /************************************************************************
       * Starttransition:
       ***********************************************************************/

      case state_type_id_start:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_start, kSCNoAwakeDelay,
                                  &v_signal_read);
        }
        v_cur_state = state_type_id_closed;
        goto nextstate;

      /************************************************************************
       * Zustand 'closed':
       ***********************************************************************/

      case state_type_id_closed:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_closed, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_closed)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_upo:
              sigparam_upo = (SigParam_upo *)RetrieveInputData();
              assert(sigparam_upo);
              v_sp = sigparam_upo->sig_field_1;
              v_tout = sigparam_upo->sig_field_2;
              v_toa = sigparam_upo->sig_field_3;
              v_prec = sigparam_upo->sig_field_4;
              v_sec = sigparam_upo->sig_field_5;
              delete sigparam_upo;
              break;

            case sig_type_id_fspo:
              sigparam_fspo = (SigParam_fspo *)RetrieveInputData();
              assert(sigparam_fspo);
              v_sp = sigparam_fspo->sig_field_1;
              v_dp = sigparam_fspo->sig_field_2;
              v_da = sigparam_fspo->sig_field_3;
              v_tout = sigparam_fspo->sig_field_4;
              v_toa = sigparam_fspo->sig_field_5;
              v_prec = sigparam_fspo->sig_field_6;
              v_sec = sigparam_fspo->sig_field_7;
              delete sigparam_fspo;
              break;

            case sig_type_id_ao:
              sigparam_ao = (SigParam_ao *)RetrieveInputData();
              assert(sigparam_ao);
              v_sp = sigparam_ao->sig_field_1;
              v_dp = sigparam_ao->sig_field_2;
              v_da = sigparam_ao->sig_field_3;
              v_tout = sigparam_ao->sig_field_4;
              v_toa = sigparam_ao->sig_field_5;
              v_prec = sigparam_ao->sig_field_6;
              v_sec = sigparam_ao->sig_field_7;
              delete sigparam_ao;
              break;

            case sig_type_id_aod:
              sigparam_aod = (SigParam_aod *)RetrieveInputData();
              assert(sigparam_aod);
              v_sp = sigparam_aod->sig_field_1;
              v_dp = sigparam_aod->sig_field_2;
              v_da = sigparam_aod->sig_field_3;
              v_tout = sigparam_aod->sig_field_4;
              v_toa = sigparam_aod->sig_field_5;
              v_prec = sigparam_aod->sig_field_6;
              v_sec = sigparam_aod->sig_field_7;
              v_len = sigparam_aod->sig_field_8;
              v_psh = sigparam_aod->sig_field_9;
              v_urg = sigparam_aod->sig_field_10;
              delete sigparam_aod;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'closed'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): upo
            init(v_sp, syn_unspecified_dp, syn_unspecified_da,
                 v_tout, v_toa, v_prec, v_sec, syn_no_push_flag,
                 syn_no_urgent_flag);
            v_cur_state = state_type_id_listen;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): fspo
            init(v_sp, v_dp, v_da, v_tout, v_toa, v_prec, v_sec,
                 syn_no_push_flag, syn_no_urgent_flag);
            v_cur_state = state_type_id_listen;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): ao
            init(v_sp, v_dp, v_da, v_tout, v_toa, v_prec, v_sec,
                 syn_no_push_flag, syn_no_urgent_flag);
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_no_ack_flag,
                        syn_syn_flag, syn_no_push_flag, syn_no_urgent_flag,
                        syn_no_reset_flag, syn_no_fin_flag);
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): aod
            init(v_sp, v_dp, v_da, v_tout, v_toa, v_prec, v_sec,
                 v_psh, v_urg);
            datarequest(v_len, syn_no_ack_flag, syn_syn_flag,
                        v_urg, v_psh, syn_no_reset_flag, syn_no_fin_flag);
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): tcp_packet
            switch (v_tcp_in.field_rst)
            {
              case true:
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                break;
              case false:
                v_len = syn_no_data;
                resetrequest(v_tcp_in.field_sa, v_tcp_in.field_sp,
                             v_tcp_in.field_seq, syn_ack_flag,
                             syn_no_syn_flag, syn_no_urgent_flag,
                             syn_no_push_flag, syn_reset_flag,
                             syn_no_fin_flag);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                break;
            }
            Stop();
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'closed': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'listen':
       ***********************************************************************/

      case state_type_id_listen:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_listen, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_listen)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_sp = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_ao:
              sigparam_ao = (SigParam_ao *)RetrieveInputData();
              assert(sigparam_ao);
              v_sp = sigparam_ao->sig_field_1;
              v_dp = sigparam_ao->sig_field_2;
              v_da = sigparam_ao->sig_field_3;
              v_tout = sigparam_ao->sig_field_4;
              v_toa = sigparam_ao->sig_field_5;
              v_prec = sigparam_ao->sig_field_6;
              v_sec = sigparam_ao->sig_field_7;
              delete sigparam_ao;
              break;

            case sig_type_id_aod:
              sigparam_aod = (SigParam_aod *)RetrieveInputData();
              assert(sigparam_aod);
              v_sp = sigparam_aod->sig_field_1;
              v_dp = sigparam_aod->sig_field_2;
              v_da = sigparam_aod->sig_field_3;
              v_tout = sigparam_aod->sig_field_4;
              v_toa = sigparam_aod->sig_field_5;
              v_prec = sigparam_aod->sig_field_6;
              v_sec = sigparam_aod->sig_field_7;
              v_len = sigparam_aod->sig_field_8;
              v_psh = sigparam_aod->sig_field_9;
              v_urg = sigparam_aod->sig_field_10;
              delete sigparam_aod;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'listen'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): close
            sigparam_process_terminated = new SigParam_process_terminated;
            assert(sigparam_process_terminated);
            sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
            Output(Parent(), sig_type_process_terminated, sigparam_process_terminated);
            Stop();
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): ao
            init(v_sp, v_dp, v_da, v_tout, v_toa, v_prec, v_sec,
                 syn_no_push_flag, syn_no_urgent_flag);
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_no_ack_flag,
                        syn_syn_flag, syn_no_urgent_flag, syn_no_push_flag,
                        syn_no_reset_flag, syn_no_fin_flag);
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): aod
            init(v_sp, v_dp, v_da, v_tout, v_toa, v_prec, v_sec,
                 v_psh, v_urg);
            datarequest(v_len, syn_no_ack_flag, syn_syn_flag,
                        syn_no_urgent_flag, syn_no_push_flag,
                        syn_no_reset_flag, syn_no_fin_flag);
            v_po = true;
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_listen;
                goto nextstate;
                break;
              case true:
                acceptpacket(v_tcp_in);
                sendroutine(0, v_tcb.field_snd_nxt, syn_ack_flag,
                            syn_syn_flag, syn_no_urgent_flag,
                            syn_no_push_flag, syn_no_reset_flag,
                            syn_no_fin_flag);
                v_cur_state = state_type_id_synreceived;
                goto nextstate;
                break;
            }
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'listen': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'synreceived':
       ***********************************************************************/

      case state_type_id_synreceived:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_synreceived, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_synreceived)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_sp = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'synreceived'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): close
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_push_flag, syn_no_reset_flag, syn_fin_flag);
            sigparam_process_terminated = new SigParam_process_terminated;
            assert(sigparam_process_terminated);
            sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
            Output(Parent(), sig_type_process_terminated, sigparam_process_terminated);
            Stop();
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_synreceived;
                goto nextstate;
                break;
              case true:
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                switch (v_po)
                {
                  case true:
                    v_cur_state = state_type_id_listen;
                    goto nextstate;
                    break;
                  case false:
                    sigparam_ter = new SigParam_ter;
                    assert(sigparam_ter);
                    sigparam_ter->sig_field_1 = v_tcb.field_sp;
                    sigparam_ter->sig_field_2 = syn_reset_error;
                    Output(Parent(), sig_type_ter, sigparam_ter);
                    sigparam_process_terminated = new SigParam_process_terminated;
                    assert(sigparam_process_terminated);
                    sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                    Output(Parent(), sig_type_process_terminated,
                           sigparam_process_terminated);
                    Stop();
                    break;
                }
                break;
              case false:
                break;
            }
            checksynpacket(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                acceptpacket(v_tcp_in);
                sigparam_os = new SigParam_os;
                assert(sigparam_os);
                sigparam_os->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_os, sigparam_os);
                v_cur_state = state_type_id_established;
                goto nextstate;
                break;
              case false:
                v_cur_state = state_type_id_synreceived;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): retr_timer
            sendretransmit(v_n);
            v_cur_state = state_type_id_synreceived;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): rcv_timer
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_synreceived;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'synreceived': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'synsent':
       ***********************************************************************/

      case state_type_id_synsent:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_synsent, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_synsent)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_sp = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'synsent'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): close
            SetTimer(Now() + syn_mrtt, tim_type_to_timer);
            sigparam_process_terminated = new SigParam_process_terminated;
            assert(sigparam_process_terminated);
            sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
            Output(Parent(), sig_type_process_terminated, sigparam_process_terminated);
            v_cur_state = state_type_id_timewait;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_synsent;
                goto nextstate;
                break;
              case true:
                break;
            }
            switch (v_tcp_in.field_rst && (v_tcp_in.field_seq == v_tcb.field_iss))
            {
              case true:
                sigparam_of = new SigParam_of;
                assert(sigparam_of);
                sigparam_of->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_of, sigparam_of);
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            switch (v_tcp_in.field_syn &&  !v_tcp_in.field_ack)
            {
              case true:
                acceptpacket(v_tcp_in);
                sendroutine(syn_no_data, v_tcb.field_snd_nxt,
                            syn_ack_flag, syn_no_syn_flag, syn_no_urgent_flag,
                            syn_no_push_flag, syn_no_reset_flag,
                            syn_no_fin_flag);
                v_po = false;
                v_cur_state = state_type_id_synreceived;
                goto nextstate;
                break;
              case false:
                break;
            }
            switch ((v_tcp_in.field_syn && v_tcp_in.field_ack) &&
                    (v_tcp_in.field_an == v_tcb.field_snd_nxt))
            {
              case true:
                acceptpacket(v_tcp_in);
                sendroutine(syn_no_data, v_tcb.field_snd_nxt,
                            syn_ack_flag, syn_no_syn_flag, syn_no_urgent_flag,
                            syn_no_push_flag, syn_no_reset_flag,
                            syn_no_fin_flag);
                sigparam_os = new SigParam_os;
                assert(sigparam_os);
                sigparam_os->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_os, sigparam_os);
                v_cur_state = state_type_id_established;
                goto nextstate;
                break;
              case false:
                v_len = 0;
                resetrequest(v_tcp_in.field_sa, v_tcp_in.field_sp,
                             v_tcp_in.field_seq, syn_ack_flag,
                             syn_no_syn_flag, syn_no_urgent_flag,
                             syn_no_push_flag, syn_reset_flag,
                             syn_no_fin_flag);
                v_cur_state = state_type_id_synsent;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): rcv_timer
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): retr_timer
            sendretransmit(v_n);
            v_cur_state = state_type_id_synsent;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'synsent': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'established':
       ***********************************************************************/

      case state_type_id_established:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_established, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_established)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_send:
              sigparam_send = (SigParam_send *)RetrieveInputData();
              assert(sigparam_send);
              v_sp = sigparam_send->sig_field_1;
              v_len = sigparam_send->sig_field_2;
              v_psh = sigparam_send->sig_field_3;
              v_urg = sigparam_send->sig_field_4;
              v_tout = sigparam_send->sig_field_5;
              v_toa = sigparam_send->sig_field_6;
              delete sigparam_send;
              break;

            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_sp = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_abort:
              sigparam_abort = (SigParam_abort *)RetrieveInputData();
              assert(sigparam_abort);
              v_sp = sigparam_abort->sig_field_1;
              delete sigparam_abort;
              break;

            case sig_type_id_status:
              sigparam_status = (SigParam_status *)RetrieveInputData();
              assert(sigparam_status);
              v_sp = sigparam_status->sig_field_1;
              delete sigparam_status;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'established'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): send
            datarequest(v_len, syn_ack_flag, syn_no_syn_flag,
                        v_urg, v_psh, syn_no_reset_flag, syn_no_fin_flag);
            v_cur_state = state_type_id_established;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            v_cur_state = state_type_id_established;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): close
            datarequest(syn_no_data, syn_ack_flag, syn_no_syn_flag,
                        syn_no_urgent_flag, syn_push_flag, syn_no_reset_flag,
                        syn_fin_flag);
            v_send_data.field_fin = true;
            switch (v_send_data.field_len == 0)
            {
              case true:
                v_cur_state = state_type_id_finwait1;
                goto nextstate;
                break;
              case false:
                v_close_connection = true;
                v_cur_state = state_type_id_established;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): abort
            sigparam_process_terminated = new SigParam_process_terminated;
            assert(sigparam_process_terminated);
            sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
            Output(Parent(), sig_type_process_terminated, sigparam_process_terminated);
            Stop();
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): status
            sigparam_stresp = new SigParam_stresp;
            assert(sigparam_stresp);
            sigparam_stresp->sig_field_1 = v_tcb.field_sp;
            sigparam_stresp->sig_field_2 = v_tcb.field_dp;
            sigparam_stresp->sig_field_3 = v_tcb.field_da;
            sigparam_stresp->sig_field_4 = v_tcb.field_rcv_wnd;
            sigparam_stresp->sig_field_5 = v_tcb.field_snd_wnd;
            sigparam_stresp->sig_field_6 = v_tcb.field_aaa;
            sigparam_stresp->sig_field_7 = v_tcb.field_aar;
            sigparam_stresp->sig_field_8 = v_tcb.field_urg;
            sigparam_stresp->sig_field_9 = v_tcb.field_prec;
            sigparam_stresp->sig_field_10 = v_tcb.field_sec;
            sigparam_stresp->sig_field_11 = v_tcb.field_tout;
            Output(Parent(), sig_type_stresp, sigparam_stresp);
            v_cur_state = state_type_id_established;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 5: // Input signal(s): retr_timer
            sendretransmit(v_n);
            v_cur_state = state_type_id_established;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 6: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_established;
                goto nextstate;
                break;
              case true:
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                sigparam_closing = new SigParam_closing;
                assert(sigparam_closing);
                sigparam_closing->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_closing, sigparam_closing);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            checksequence(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_trace_block.field_bad_sequence = v_trace_block.field_bad_sequence + 1;
                break;
              case true:
                acceptpacket(v_tcp_in);
                datarequest(syn_no_data, syn_ack_flag, syn_no_syn_flag,
                            syn_no_urgent_flag, syn_no_push_flag,
                            syn_no_reset_flag, v_close_connection);
                break;
            }
            switch (v_tcp_in.field_fin)
            {
              case true:
                sigparam_closing = new SigParam_closing;
                assert(sigparam_closing);
                sigparam_closing->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_closing, sigparam_closing);
                deliverdata();
                sendroutine(syn_no_data, v_tcb.field_snd_nxt,
                            syn_ack_flag, syn_no_syn_flag, syn_no_urgent_flag,
                            syn_no_push_flag, syn_no_reset_flag,
                            syn_no_fin_flag);
                v_cur_state = state_type_id_closewait;
                goto nextstate;
                break;
              case false:
                switch (v_close_connection && (v_send_data.field_len == 0))
                {
                  case true:
                    v_cur_state = state_type_id_finwait1;
                    goto nextstate;
                    break;
                  case false:
                    break;
                }
                v_cur_state = state_type_id_established;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 7: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_established;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'established': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'finwait1':
       ***********************************************************************/

      case state_type_id_finwait1:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_finwait1, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_finwait1)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_send:
              sigparam_send = (SigParam_send *)RetrieveInputData();
              assert(sigparam_send);
              v_sp = sigparam_send->sig_field_1;
              v_len = sigparam_send->sig_field_2;
              v_psh = sigparam_send->sig_field_3;
              v_urg = sigparam_send->sig_field_4;
              v_tout = sigparam_send->sig_field_5;
              v_toa = sigparam_send->sig_field_6;
              delete sigparam_send;
              break;

            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'finwait1'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): send
            v_cur_state = state_type_id_finwait1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            deliverdata();
            v_cur_state = state_type_id_finwait1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_finwait1;
                goto nextstate;
                break;
              case true:
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            checksequence(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                resetrequest(v_tcp_in.field_sa, v_tcp_in.field_sp,
                             v_tcp_in.field_seq, syn_ack_flag,
                             syn_no_syn_flag, syn_no_urgent_flag,
                             syn_no_push_flag, syn_reset_flag,
                             syn_no_fin_flag);
                v_cur_state = state_type_id_finwait1;
                goto nextstate;
                break;
              case true:
                acceptpacket(v_tcp_in);
                switch (v_tcp_in.field_fin)
                {
                  case true:
                    sendroutine(0, v_tcb.field_snd_nxt, syn_ack_flag,
                                syn_no_syn_flag, syn_no_urgent_flag,
                                syn_no_push_flag, syn_no_reset_flag,
                                syn_fin_flag);
                    sigparam_closing = new SigParam_closing;
                    assert(sigparam_closing);
                    sigparam_closing->sig_field_1 = v_tcb.field_sp;
                    Output(Parent(), sig_type_closing, sigparam_closing);
                    v_cur_state = state_type_id_closing;
                    goto nextstate;
                    break;
                  case false:
                    break;
                }
                switch (v_tcb.field_snd_nxt == v_tcp_in.field_an)
                {
                  case true:
                    v_cur_state = state_type_id_finwait2;
                    goto nextstate;
                    break;
                  case false:
                    v_cur_state = state_type_id_finwait1;
                    goto nextstate;
                    break;
                }
                break;
            }
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): retr_timer
            sendretransmit(v_n);
            switch (v_ok)
            {
              case false:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            v_cur_state = state_type_id_finwait1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_finwait1;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'finwait1': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'finwait2':
       ***********************************************************************/

      case state_type_id_finwait2:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_finwait2, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_finwait2)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_send:
              sigparam_send = (SigParam_send *)RetrieveInputData();
              assert(sigparam_send);
              v_sp = sigparam_send->sig_field_1;
              v_len = sigparam_send->sig_field_2;
              v_psh = sigparam_send->sig_field_3;
              v_urg = sigparam_send->sig_field_4;
              v_tout = sigparam_send->sig_field_5;
              v_toa = sigparam_send->sig_field_6;
              delete sigparam_send;
              break;

            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'finwait2'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): send
            v_cur_state = state_type_id_finwait2;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            deliverdata();
            switch ((v_rec_data.field_len == 0) && v_close_received)
            {
              case true:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                v_cur_state = state_type_id_finwait2;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_finwait2;
                goto nextstate;
                break;
              case true:
                isreset(v_tcp_in, v_ok);
                switch (v_ok)
                {
                  case true:
                    sigparam_process_terminated = new SigParam_process_terminated;
                    assert(sigparam_process_terminated);
                    sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                    Output(Parent(), sig_type_process_terminated,
                           sigparam_process_terminated);
                    SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                    v_cur_state = state_type_id_timewait;
                    goto nextstate;
                    break;
                  case false:
                    checksequence(v_tcp_in, v_ok);
                    switch (v_ok)
                    {
                      case false:
                        v_cur_state = state_type_id_finwait2;
                        goto nextstate;
                        break;
                      case true:
                        acceptpacket(v_tcp_in);
                        sendroutine(syn_no_data, v_tcb.field_snd_nxt,
                                    syn_ack_flag, syn_no_syn_flag,
                                    syn_no_urgent_flag, syn_no_push_flag,
                                    syn_no_reset_flag, syn_fin_flag);
                        switch (v_tcp_in.field_fin)
                        {
                          case false:
                            v_cur_state = state_type_id_finwait2;
                            goto nextstate;
                            break;
                          case true:
                            switch (v_rec_data.field_len > 0)
                            {
                              case true:
                                v_close_received = true;
                                v_cur_state = state_type_id_finwait2;
                                goto nextstate;
                                break;
                              case false:
                                sigparam_process_terminated = new SigParam_process_terminated;
                                assert(sigparam_process_terminated);
                                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                                Output(Parent(), sig_type_process_terminated,
                                       sigparam_process_terminated);
                                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                                v_cur_state = state_type_id_timewait;
                                goto nextstate;
                                break;
                            }
                            break;
                        }
                        break;
                    }
                    break;
                }
                break;
            }
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): retr_timer
            sendretransmit(v_n);
            switch (v_ok)
            {
              case false:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            v_cur_state = state_type_id_finwait2;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_finwait2;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'finwait2': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'closing':
       ***********************************************************************/

      case state_type_id_closing:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_closing, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_closing)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'closing'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            deliverdata();
            switch ((v_rec_data.field_len == syn_no_data) &&
                    v_close_received)
            {
              case true:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                v_cur_state = state_type_id_finwait2;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                break;
              case false:
                v_cur_state = state_type_id_closing;
                goto nextstate;
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            checksequence(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_closing;
                goto nextstate;
                break;
              case true:
                acceptpacket(v_tcp_in);
                break;
            }
            switch (v_tcp_in.field_an == v_tcb.field_snd_nxt)
            {
              case true:
                switch (v_rec_data.field_len == 0)
                {
                  case true:
                    SetTimer(Now() + syn_time_out, tim_type_to_timer);
                    sigparam_process_terminated = new SigParam_process_terminated;
                    assert(sigparam_process_terminated);
                    sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                    Output(Parent(), sig_type_process_terminated,
                           sigparam_process_terminated);
                    v_cur_state = state_type_id_timewait;
                    goto nextstate;
                    break;
                  case false:
                    v_close_received = true;
                    break;
                }
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_closing;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): retr_timer
            sendretransmit(v_n);
            switch (v_ok)
            {
              case false:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            v_cur_state = state_type_id_closing;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_closing;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'closing': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'closewait':
       ***********************************************************************/

      case state_type_id_closewait:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_closewait, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_closewait)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_sp = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_send:
              sigparam_send = (SigParam_send *)RetrieveInputData();
              assert(sigparam_send);
              v_sp = sigparam_send->sig_field_1;
              v_len = sigparam_send->sig_field_2;
              v_psh = sigparam_send->sig_field_3;
              v_urg = sigparam_send->sig_field_4;
              v_tout = sigparam_send->sig_field_5;
              v_toa = sigparam_send->sig_field_6;
              delete sigparam_send;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'closewait'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_closewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            checksequence(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_closewait;
                goto nextstate;
                break;
              case true:
                acceptpacket(v_tcp_in);
                datarequest(syn_no_data, syn_ack_flag, syn_no_syn_flag,
                            syn_no_urgent_flag, syn_no_push_flag,
                            syn_no_reset_flag, syn_no_fin_flag);
                switch ((v_send_data.field_len == 0) && v_close_connection)
                {
                  case true:
                    v_cur_state = state_type_id_lastack;
                    goto nextstate;
                    break;
                  case false:
                    break;
                }
                v_cur_state = state_type_id_closewait;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): to_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_time_out, tim_type_to_timer);
            v_cur_state = state_type_id_closewait;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): retr_timer
            sendretransmit(v_n);
            switch (v_ok)
            {
              case false:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            v_cur_state = state_type_id_closewait;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            deliverdata();
            v_cur_state = state_type_id_closewait;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): close
            datarequest(syn_no_data, syn_ack_flag, syn_no_syn_flag,
                        syn_no_urgent_flag, syn_push_flag, syn_no_reset_flag,
                        syn_fin_flag);
            switch (v_send_data.field_len == 0)
            {
              case true:
                v_cur_state = state_type_id_lastack;
                goto nextstate;
                break;
              case false:
                v_close_connection = true;
                v_cur_state = state_type_id_closewait;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 5: // Input signal(s): send
            datarequest(v_len, syn_ack_flag, syn_no_syn_flag,
                        v_urg, v_psh, syn_no_reset_flag, syn_no_fin_flag);
            v_cur_state = state_type_id_closewait;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 6: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            v_cur_state = state_type_id_closewait;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'closewait': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'lastack':
       ***********************************************************************/

      case state_type_id_lastack:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_lastack, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_lastack)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_sp = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case tim_type_id_retr_timer:
              timparam_retr_timer = (TimParam_retr_timer *)RetrieveInputData();
              assert(timparam_retr_timer);
              v_n = timparam_retr_timer->tim_field_1;
              delete timparam_retr_timer;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'lastack'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): allocate
            v_rbuffer = v_rbuffer + v_len;
            deliverdata();
            switch ((v_rec_data.field_len == 0) && v_close_connection)
            {
              case true:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                v_cur_state = state_type_id_lastack;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): tcp_packet
            checkchecksum(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_lastack;
                goto nextstate;
                break;
              case true:
                break;
            }
            isreset(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case false:
                break;
            }
            checksequence(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case false:
                v_cur_state = state_type_id_lastack;
                goto nextstate;
                break;
              case true:
                acceptpacket(v_tcp_in);
                break;
            }
            islastack(v_tcp_in, v_ok);
            switch (v_ok)
            {
              case true:
                switch (v_rec_data.field_len == 0)
                {
                  case true:
                    SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                    sigparam_process_terminated = new SigParam_process_terminated;
                    assert(sigparam_process_terminated);
                    sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                    Output(Parent(), sig_type_process_terminated,
                           sigparam_process_terminated);
                    v_cur_state = state_type_id_timewait;
                    goto nextstate;
                    break;
                  case false:
                    v_close_connection = true;
                    v_cur_state = state_type_id_lastack;
                    goto nextstate;
                    break;
                }
                break;
              case false:
                v_cur_state = state_type_id_lastack;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): retr_timer
            sendretransmit(v_n);
            switch (v_ok)
            {
              case false:
                SetTimer(Now() + syn_mrtt, tim_type_to_timer);
                sigparam_process_terminated = new SigParam_process_terminated;
                assert(sigparam_process_terminated);
                sigparam_process_terminated->sig_field_1 = v_tcb.field_sp;
                Output(Parent(), sig_type_process_terminated,
                       sigparam_process_terminated);
                v_cur_state = state_type_id_timewait;
                goto nextstate;
                break;
              case true:
                break;
            }
            v_cur_state = state_type_id_lastack;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): rcv_timer
            sendroutine(syn_no_data, v_tcb.field_snd_nxt, syn_ack_flag,
                        syn_no_syn_flag, syn_no_urgent_flag,
                        syn_no_push_flag, syn_no_reset_flag,
                        syn_no_fin_flag);
            SetTimer(Now() + syn_wait_delay, tim_type_rcv_timer);
            v_cur_state = state_type_id_lastack;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'lastack': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'timewait':
       ***********************************************************************/

      case state_type_id_timewait:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_timewait, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_timewait)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'timewait'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): to_timer
            sigparam_ter = new SigParam_ter;
            assert(sigparam_ter);
            sigparam_ter->sig_field_1 = v_tcb.field_sp;
            sigparam_ter->sig_field_2 = 0;
            Output(Parent(), sig_type_ter, sigparam_ter);
            Stop();
            break;

          case kSCTransitionIDBase + 1: // Input *
            v_cur_state = state_type_id_timewait;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'timewait': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      default:
        std::cerr << "Process 'port': Invalid process state." <<
                     std::endl;
        break;
    }
  }
}

/******************************************************************************
 * Save-Methode zur Speicherung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_tcp_port::Save(SCMem &save_area) const
{
  /****************************************************************************
   * Speicherung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Save(save_area);

  /****************************************************************************
   * Sicherung der Variablen:
   ***************************************************************************/

  v_tcb.Save(save_area);
  v_tcp_in.Save(save_area);
  v_rec_data.Save(save_area);
  v_send_data.Save(save_area);
  v_retransmit_queue.Save(save_area);
  save_area.Store(&v_po, sizeof(SCBoolean));
  save_area.Store(&v_ok, sizeof(SCBoolean));
  save_area.Store(&v_psh, sizeof(SCBoolean));
  save_area.Store(&v_urg, sizeof(SCBoolean));
  save_area.Store(&v_close_connection, sizeof(SCBoolean));
  save_area.Store(&v_close_received, sizeof(SCBoolean));
  save_area.Store(&v_fin_tmp, sizeof(SCBoolean));
  v_n.Save(save_area);
  save_area.Store(&v_oldest, sizeof(SCInteger));
  save_area.Store(&v_sp, sizeof(SCInteger));
  save_area.Store(&v_tout, sizeof(SCInteger));
  save_area.Store(&v_toa, sizeof(SCInteger));
  save_area.Store(&v_prec, sizeof(SCInteger));
  save_area.Store(&v_sec, sizeof(SCInteger));
  save_area.Store(&v_len, sizeof(SCInteger));
  save_area.Store(&v_da, sizeof(SCInteger));
  save_area.Store(&v_dp, sizeof(SCInteger));
  save_area.Store(&v_rbuffer, sizeof(SCInteger));
  v_trace_block.Save(save_area);

  /****************************************************************************
   * Speicherung der Zustandsvariablen
   ***************************************************************************/

  save_area.Store(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_tcp_port::Restore(SCMem &save_area)
{
  /****************************************************************************
   * Restaurierung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Restore(save_area);

  /****************************************************************************
   * Restaurierung der Variablen:
   ***************************************************************************/

  v_tcb.Restore(save_area);
  v_tcp_in.Restore(save_area);
  v_rec_data.Restore(save_area);
  v_send_data.Restore(save_area);
  v_retransmit_queue.Restore(save_area);
  save_area.Restore(&v_po, sizeof(SCBoolean));
  save_area.Restore(&v_ok, sizeof(SCBoolean));
  save_area.Restore(&v_psh, sizeof(SCBoolean));
  save_area.Restore(&v_urg, sizeof(SCBoolean));
  save_area.Restore(&v_close_connection, sizeof(SCBoolean));
  save_area.Restore(&v_close_received, sizeof(SCBoolean));
  save_area.Restore(&v_fin_tmp, sizeof(SCBoolean));
  v_n.Restore(save_area);
  save_area.Restore(&v_oldest, sizeof(SCInteger));
  save_area.Restore(&v_sp, sizeof(SCInteger));
  save_area.Restore(&v_tout, sizeof(SCInteger));
  save_area.Restore(&v_toa, sizeof(SCInteger));
  save_area.Restore(&v_prec, sizeof(SCInteger));
  save_area.Restore(&v_sec, sizeof(SCInteger));
  save_area.Restore(&v_len, sizeof(SCInteger));
  save_area.Restore(&v_da, sizeof(SCInteger));
  save_area.Restore(&v_dp, sizeof(SCInteger));
  save_area.Restore(&v_rbuffer, sizeof(SCInteger));
  v_trace_block.Restore(save_area);

  /****************************************************************************
   * Restaurierung der Zustandsvariablen
   ***************************************************************************/

  save_area.Restore(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz
 *****************************************************************************/

void pcs_tcp_port::Size(SCSize *cur_size) const
{
  /****************************************************************************
   * Berechnung der Groesse der Basisklasse
   ***************************************************************************/

  SCProcess::Size(cur_size);

  /****************************************************************************
   * Berechnung der Variablengroessen:
   ***************************************************************************/

  v_tcb.Size(cur_size);
  v_tcp_in.Size(cur_size);
  v_rec_data.Size(cur_size);
  v_send_data.Size(cur_size);
  v_retransmit_queue.Size(cur_size);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  v_n.Size(cur_size);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  v_trace_block.Size(cur_size);

  /****************************************************************************
   * Groesse der Zustandsvariablen
   ***************************************************************************/

  cur_size->size += sizeof(v_cur_state);

}

/******************************************************************************
 * Display-Methode
 *****************************************************************************/

SCStream& operator<<(SCStream &out, const pcs_tcp_port &me)
{
  return me.Display(out);
}
