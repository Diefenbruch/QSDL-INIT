/******************************************************************************
 *                            pcs_tcp_port.h
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef _PCS_TCP_PORT_H_
#define _PCS_TCP_PORT_H_

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_tcp.h"

#include <SCL/SCProcess.h>
#include <SCL/SCStateType.h>
#include <SCL/SCTimerType.h>
#include <SCL/SCProcedureType.h>

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'port' (Data)
 *****************************************************************************/

class pcs_tcp_port_data : public blk_tcp
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktor
     *************************************************************************/

    pcs_tcp_port_data(void);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_tcp_port_data(void);

    /**************************************************************************
     * Prozedurtypen (statisch)
     *************************************************************************/


    /**************************************************************************
     * IDs der Timertypen auf Prozessebene
     *************************************************************************/

    enum
    {
      tim_type_id_retr_timer = kSCSignalTypeIDBase + 23,
      tim_type_id_to_timer,
      tim_type_id_rcv_timer,
      tim_type_id_accept_timer,
      tim_type_id_create_packet_timer
    };

    /**************************************************************************
     * Strukturen fuer die Timerparameter
     *************************************************************************/

    struct TimParam_retr_timer : public SCDataType
    {
      // Default Konstruktor:
      TimParam_retr_timer(void)
      {
        tim_field_1 = 0;
      }
      // Copy Konstruktor:
      TimParam_retr_timer(const TimParam_retr_timer& orig)
      {
        *this = orig;
      }
      integer tim_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new TimParam_retr_timer(*this);
      }
      // Zuweisungsoperator:
      TimParam_retr_timer& operator= (const TimParam_retr_timer &orig)
      {
        tim_field_1 = orig.tim_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const TimParam_retr_timer &second) const
      {
        return (tim_field_1 == second.tim_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(TimParam_retr_timer *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const TimParam_retr_timer &me)
      {
        out << me.tim_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&tim_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&tim_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };

    /**************************************************************************
     * Variablen fuer die Timerparameter
     *************************************************************************/

    TimParam_retr_timer *timparam_retr_timer;

    /**************************************************************************
     * Timertypen auf Prozessebene (statisch)
     *************************************************************************/

    struct TimType_retr_timer: public SCTimerType
    {
      TimType_retr_timer(SCNatural type_key, const char *type_name) :
        SCTimerType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new TimParam_retr_timer;
      }
    };
    static TimType_retr_timer * tim_type_retr_timer;
    static SCTimerType * tim_type_to_timer;
    static SCTimerType * tim_type_rcv_timer;
    static SCTimerType * tim_type_accept_timer;
    static SCTimerType * tim_type_create_packet_timer;

    /**************************************************************************
     * Benutzerdefinierte SDL-Datentypen auf Prozessebene
     *************************************************************************/

    /**************************************************************************
     * SDL-Newtype: Struct 'traceblockprotocol':
     *************************************************************************/

    struct DataType_traceblockprotocol : public SCDataType
    {
      // Default Konstruktor:
      DataType_traceblockprotocol(void)
      {
        field_retransmitted = 0;
        field_bad_checksum = 0;
        field_bad_sequence = 0;
        field_is_reset = 0;
        field_packetoutput = 0;
      }
      // Copy Konstruktor:
      DataType_traceblockprotocol(const DataType_traceblockprotocol& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_retransmitted;
      SCInteger field_bad_checksum;
      SCInteger field_bad_sequence;
      SCInteger field_is_reset;
      SCInteger field_packetoutput;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_traceblockprotocol(*this);
      }
      // Zuweisungsoperator:
      DataType_traceblockprotocol& operator= (const DataType_traceblockprotocol &orig)
      {
        field_retransmitted = orig.field_retransmitted;
        field_bad_checksum = orig.field_bad_checksum;
        field_bad_sequence = orig.field_bad_sequence;
        field_is_reset = orig.field_is_reset;
        field_packetoutput = orig.field_packetoutput;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_traceblockprotocol &second) const
      {
        return (field_retransmitted == second.field_retransmitted &&
                field_bad_checksum == second.field_bad_checksum &&
                field_bad_sequence == second.field_bad_sequence &&
                field_is_reset == second.field_is_reset &&
                field_packetoutput == second.field_packetoutput);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_traceblockprotocol *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_traceblockprotocol &me)
      {
        out << "[";
        out << me.field_retransmitted << ", ";
        out << me.field_bad_checksum << ", ";
        out << me.field_bad_sequence << ", ";
        out << me.field_is_reset << ", ";
        out << me.field_packetoutput;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_retransmitted, sizeof(SCInteger));
        save_area.Store(&field_bad_checksum, sizeof(SCInteger));
        save_area.Store(&field_bad_sequence, sizeof(SCInteger));
        save_area.Store(&field_is_reset, sizeof(SCInteger));
        save_area.Store(&field_packetoutput, sizeof(SCInteger));
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_retransmitted, sizeof(SCInteger));
        save_area.HistoryStore(&field_bad_checksum, sizeof(SCInteger));
        save_area.HistoryStore(&field_bad_sequence, sizeof(SCInteger));
        save_area.HistoryStore(&field_is_reset, sizeof(SCInteger));
        save_area.HistoryStore(&field_packetoutput, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_retransmitted, sizeof(SCInteger));
        save_area.Restore(&field_bad_checksum, sizeof(SCInteger));
        save_area.Restore(&field_bad_sequence, sizeof(SCInteger));
        save_area.Restore(&field_is_reset, sizeof(SCInteger));
        save_area.Restore(&field_packetoutput, sizeof(SCInteger));
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_retransmitted, sizeof(SCInteger));
        save_area.HistoryRestore(&field_bad_checksum, sizeof(SCInteger));
        save_area.HistoryRestore(&field_bad_sequence, sizeof(SCInteger));
        save_area.HistoryRestore(&field_is_reset, sizeof(SCInteger));
        save_area.HistoryRestore(&field_packetoutput, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
      }
    };

    static SCInteger syn_no_data;
    static SCInteger syn_unspecified_dp;
    static SCInteger syn_unspecified_da;
    static SCInteger syn_reset_error;

    /**************************************************************************
     * IDs der Prozedurtypen
     *************************************************************************/

    enum
    {
      pcd_type_id_sendroutine = kSCProcedureTypeIDBase + 2,
      pcd_type_id_datarequest,
      pcd_type_id_resetrequest,
      pcd_type_id_sendstandard,
      pcd_type_id_addretransmit,
      pcd_type_id_getfreebuffer,
      pcd_type_id_sendretransmit,
      pcd_type_id_updateretransmit,
      pcd_type_id_updatetcb,
      pcd_type_id_acceptpacket,
      pcd_type_id_checkchecksum,
      pcd_type_id_checksynpacket,
      pcd_type_id_checksequence,
      pcd_type_id_isreset,
      pcd_type_id_initretransmitqueue,
      pcd_type_id_init,
      pcd_type_id_deliverdata,
      pcd_type_id_islastack
    };

    /**************************************************************************
     * Strukturen fuer die formalen Parameter der Prozeduren
     *************************************************************************/


    /**************************************************************************
     * Variablen fuer die formalen Parameter der Prozeduren
     *************************************************************************/


};

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'port' (Instanz)
 *****************************************************************************/

class pcs_tcp_port : public SCProcess, public pcs_tcp_port_data
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktoren
     *************************************************************************/

    pcs_tcp_port(const SCProcessID, const SCProcessType *);
    pcs_tcp_port(SCMem &);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_tcp_port(void);

    /**************************************************************************
     * Prototypen fuer die Prozeduren
     *************************************************************************/

    void sendroutine(SCInteger, SCInteger, SCBoolean, SCBoolean,
                     SCBoolean, SCBoolean, SCBoolean, SCBoolean);
    void datarequest(SCInteger, SCBoolean, SCBoolean, SCBoolean,
                     SCBoolean, SCBoolean, SCBoolean);
    void resetrequest(SCInteger, SCInteger, SCInteger, SCBoolean,
                      SCBoolean, SCBoolean, SCBoolean, SCBoolean,
                      SCBoolean);
    void sendstandard(void);
    void addretransmit(DataType_tcp);
    void getfreebuffer(DataType_retransmitrange &);
    void sendretransmit(DataType_retransmitrange);
    void updateretransmit(DataType_tcp);
    void updatetcb(DataType_tcp);
    void acceptpacket(DataType_tcp);
    void checkchecksum(DataType_tcp, SCBoolean &);
    void checksynpacket(DataType_tcp, SCBoolean &);
    void checksequence(DataType_tcp, SCBoolean &);
    void isreset(DataType_tcp, SCBoolean &);
    void initretransmitqueue(DataType_retransmitrange);
    void init(SCInteger, SCInteger, SCInteger, SCInteger, SCInteger,
              SCInteger, SCInteger, SCBoolean, SCBoolean);
    void deliverdata(void);
    void islastack(DataType_tcp, SCBoolean &);

    /**************************************************************************
     * Virtuelle Save- & Restore-Methoden
     *************************************************************************/

    SCBoolean Save(SCMem &) const;
    SCBoolean Restore(SCMem &);

    /**************************************************************************
     * Virtuelle Size-Methode
     *************************************************************************/

    void Size(SCSize *) const;

    /**************************************************************************
     * Display-Methoden
     *************************************************************************/

    friend SCStream& operator<<(SCStream &, const pcs_tcp_port &);

    /**************************************************************************
     * Implementierungsmethode
     *************************************************************************/

    void Body(void);

    /**************************************************************************
     * Lokale Variablen des Prozesses
     *************************************************************************/

    DataType_tcbblock v_tcb;
    DataType_tcp v_tcp_in;
    DataType_transmitdata v_rec_data;
    DataType_transmitdata v_send_data;
    DataType_listofretrpackets v_retransmit_queue;
    SCBoolean v_po;
    SCBoolean v_ok;
    SCBoolean v_psh;
    SCBoolean v_urg;
    SCBoolean v_close_connection;
    SCBoolean v_close_received;
    SCBoolean v_fin_tmp;
    DataType_retransmitrange v_n;
    SCInteger v_oldest;
    SCInteger v_sp;
    SCInteger v_tout;
    SCInteger v_toa;
    SCInteger v_prec;
    SCInteger v_sec;
    SCInteger v_len;
    SCInteger v_da;
    SCInteger v_dp;
    SCInteger v_rbuffer;
    DataType_traceblockprotocol v_trace_block;

    /**************************************************************************
     * IDs der Zustandstypen des Prozesses
     *************************************************************************/

    enum
    {
      state_type_id_start = kSCStateTypeIDBase + 18,
      state_type_id_closed,
      state_type_id_listen,
      state_type_id_synreceived,
      state_type_id_synsent,
      state_type_id_established,
      state_type_id_finwait1,
      state_type_id_finwait2,
      state_type_id_closing,
      state_type_id_closewait,
      state_type_id_lastack,
      state_type_id_timewait
    };

    /**************************************************************************
     * Zustandstypen des Prozesses (statisch)
     *************************************************************************/

    static SCStateType * state_type_start;
    static SCStateType * state_type_closed;
    static SCStateType * state_type_listen;
    static SCStateType * state_type_synreceived;
    static SCStateType * state_type_synsent;
    static SCStateType * state_type_established;
    static SCStateType * state_type_finwait1;
    static SCStateType * state_type_finwait2;
    static SCStateType * state_type_closing;
    static SCStateType * state_type_closewait;
    static SCStateType * state_type_lastack;
    static SCStateType * state_type_timewait;

    /**************************************************************************
     * Input-Sets der Transitionen des Prozesses (statisch)
     *************************************************************************/

    static SCSignalID input_set_closed_transition0[];
    static SCSignalID input_set_closed_transition1[];
    static SCSignalID input_set_closed_transition2[];
    static SCSignalID input_set_closed_transition3[];
    static SCSignalID input_set_closed_transition4[];
    static SCSignalID input_set_listen_transition0[];
    static SCSignalID input_set_listen_transition1[];
    static SCSignalID input_set_listen_transition2[];
    static SCSignalID input_set_listen_transition3[];
    static SCSignalID input_set_synreceived_transition0[];
    static SCSignalID input_set_synreceived_transition1[];
    static SCSignalID input_set_synreceived_transition2[];
    static SCSignalID input_set_synreceived_transition3[];
    static SCSignalID input_set_synsent_transition0[];
    static SCSignalID input_set_synsent_transition1[];
    static SCSignalID input_set_synsent_transition2[];
    static SCSignalID input_set_synsent_transition3[];
    static SCSignalID input_set_established_transition0[];
    static SCSignalID input_set_established_transition1[];
    static SCSignalID input_set_established_transition2[];
    static SCSignalID input_set_established_transition3[];
    static SCSignalID input_set_established_transition4[];
    static SCSignalID input_set_established_transition5[];
    static SCSignalID input_set_established_transition6[];
    static SCSignalID input_set_established_transition7[];
    static SCSignalID input_set_finwait1_transition0[];
    static SCSignalID input_set_finwait1_transition1[];
    static SCSignalID input_set_finwait1_transition2[];
    static SCSignalID input_set_finwait1_transition3[];
    static SCSignalID input_set_finwait1_transition4[];
    static SCSignalID input_set_finwait2_transition0[];
    static SCSignalID input_set_finwait2_transition1[];
    static SCSignalID input_set_finwait2_transition2[];
    static SCSignalID input_set_finwait2_transition3[];
    static SCSignalID input_set_finwait2_transition4[];
    static SCSignalID input_set_closing_transition0[];
    static SCSignalID input_set_closing_transition1[];
    static SCSignalID input_set_closing_transition2[];
    static SCSignalID input_set_closing_transition3[];
    static SCSignalID input_set_closewait_transition0[];
    static SCSignalID input_set_closewait_transition1[];
    static SCSignalID input_set_closewait_transition2[];
    static SCSignalID input_set_closewait_transition3[];
    static SCSignalID input_set_closewait_transition4[];
    static SCSignalID input_set_closewait_transition5[];
    static SCSignalID input_set_closewait_transition6[];
    static SCSignalID input_set_lastack_transition0[];
    static SCSignalID input_set_lastack_transition1[];
    static SCSignalID input_set_lastack_transition2[];
    static SCSignalID input_set_lastack_transition3[];
    static SCSignalID input_set_timewait_transition0[];
    static SCSignalID input_set_timewait_transition1[];

    /**************************************************************************
     * Standardvariablen zur Prozesssteuerung
     *************************************************************************/

    SCInteger v_cur_state;
    SCInteger v_transition_id;
    SCTransition *v_transition;
    SCSignalType *v_signal_read;

    /**************************************************************************
     * Friend-Deklarationen fuer Prozeduren
     *************************************************************************/

};

#endif
