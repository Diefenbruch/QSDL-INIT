/******************************************************************************
 *                            pcs_application_loadgenerator.h
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef _PCS_APPLICATION_LOADGENERATOR_H_
#define _PCS_APPLICATION_LOADGENERATOR_H_

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"

#include <SCL/SCProcess.h>
#include <SCL/SCStateType.h>
#include <SCL/SCTimerType.h>
#include <SCL/SCProcedureType.h>

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'loadgenerator' (Data)
 *****************************************************************************/

class pcs_application_loadgenerator_data : public blk_application
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktor
     *************************************************************************/

    pcs_application_loadgenerator_data(void);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_application_loadgenerator_data(void);

    /**************************************************************************
     * IDs der Timertypen auf Prozessebene
     *************************************************************************/

    enum
    {
      tim_type_id_send_init = kSCSignalTypeIDBase + 20,
      tim_type_id_send_fin
    };

    /**************************************************************************
     * Timertypen auf Prozessebene (statisch)
     *************************************************************************/

    static SCTimerType * tim_type_send_init;
    static SCTimerType * tim_type_send_fin;

    /**************************************************************************
     * Benutzerdefinierte SDL-Datentypen auf Prozessebene
     *************************************************************************/

    static SCInteger syn_data;
    static SCInteger syn_port_1;
    static SCInteger syn_port_2;
    /**************************************************************************
     * SDL-Syntype: 'twoports':
     *************************************************************************/

    struct DataType_twoports : public SCSyntype<SCInteger>
    {
      DataType_twoports(void) : SCSyntype<SCInteger> (1, 2, 1,
                                                      NULL) {}
      DataType_twoports(SCInteger init) : SCSyntype<SCInteger> (1,
                                                                2,
                                                                init,
                                                                NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_twoports& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Syntype: 'numberofports':
     *************************************************************************/

    struct DataType_numberofports : public SCSyntype<SCInteger>
    {
      DataType_numberofports(void) : SCSyntype<SCInteger> (0,
                                                           syn_num_of_connections * 2,
                                                           0,
                                                           NULL) {}
      DataType_numberofports(SCInteger init) : SCSyntype<SCInteger> (0,
                                                                     syn_num_of_connections * 2,
                                                                     init,
                                                                     NULL) {}
      // Zuweisungsoperator von Basistyp auf Syntype:
      DataType_numberofports& operator=(SCInteger new_value)
      {
        SetValue(new_value);
        return *this;
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&value, sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
      }
    };
    /**************************************************************************
     * SDL-Newtype: Array 'receiveblock':
     *************************************************************************/

    struct DataType_receiveblock : public SCArray<SCInteger>
    {
      // Konstruktor:
      DataType_receiveblock(void) : SCArray<SCInteger> (1, 2,
                                                        (SCInteger)0) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCInteger));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCInteger));
      }
    };
    /**************************************************************************
     * SDL-Newtype: Array 'addressid':
     *************************************************************************/

    struct DataType_addressid : public SCArray<SCInteger>
    {
      // Konstruktor:
      DataType_addressid(void) : SCArray<SCInteger> (1, 2, (SCInteger)0) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCInteger));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCInteger));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCInteger));
      }
    };
    /**************************************************************************
     * SDL-Newtype: Struct 'traceblockstructure':
     *************************************************************************/

    struct DataType_traceblockstructure : public SCDataType
    {
      // Default Konstruktor:
      DataType_traceblockstructure(void)
      {
        field_failed_connection = 0;
        field_succeeded_connection = 0;
      }
      // Copy Konstruktor:
      DataType_traceblockstructure(const DataType_traceblockstructure& orig)
      {
        *this = orig;
      }
      // Felder:
      SCInteger field_failed_connection;
      SCInteger field_succeeded_connection;
      DataType_receiveblock field_received;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new DataType_traceblockstructure(*this);
      }
      // Zuweisungsoperator:
      DataType_traceblockstructure& operator= (const DataType_traceblockstructure &orig)
      {
        field_failed_connection = orig.field_failed_connection;
        field_succeeded_connection = orig.field_succeeded_connection;
        field_received = orig.field_received;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const DataType_traceblockstructure &second) const
      {
        return (field_failed_connection == second.field_failed_connection &&
                field_succeeded_connection == second.field_succeeded_connection &&
                field_received == second.field_received);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(DataType_traceblockstructure *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const DataType_traceblockstructure &me)
      {
        out << "[";
        out << me.field_failed_connection << ", ";
        out << me.field_succeeded_connection << ", ";
        out << me.field_received;
        out << "]";
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&field_failed_connection, sizeof(SCInteger));
        save_area.Store(&field_succeeded_connection, sizeof(SCInteger));
        field_received.Save(save_area);
        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(&field_failed_connection, sizeof(SCInteger));
        save_area.HistoryStore(&field_succeeded_connection, sizeof(SCInteger));
        field_received.HistorySave(save_area);
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&field_failed_connection, sizeof(SCInteger));
        save_area.Restore(&field_succeeded_connection, sizeof(SCInteger));
        field_received.Restore(save_area);
        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(&field_failed_connection, sizeof(SCInteger));
        save_area.HistoryRestore(&field_succeeded_connection,
                                 sizeof(SCInteger));
        field_received.HistoryRestore(save_area);
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
        cur_size->size += sizeof(SCInteger);
        field_received.Size(cur_size);
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += sizeof(SCInteger);
        cur_size->historySize += sizeof(SCInteger);
        field_received.HistorySize(cur_size);
      }
    };


};

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'loadgenerator' (Instanz)
 *****************************************************************************/

class pcs_application_loadgenerator : public SCProcess, public pcs_application_loadgenerator_data
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktoren
     *************************************************************************/

    pcs_application_loadgenerator(const SCProcessID, const SCProcessType *,
                                  PcsFormalParam_loadgenerator* = NULL);
    pcs_application_loadgenerator(SCMem &);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_application_loadgenerator(void);

    /**************************************************************************
     * Virtuelle Save- & Restore-Methoden
     *************************************************************************/

    SCBoolean Save(SCMem &) const;
    SCBoolean Restore(SCMem &);

    /**************************************************************************
     * Virtuelle Size-Methode
     *************************************************************************/

    void Size(SCSize *) const;

    /**************************************************************************
     * Display-Methoden
     *************************************************************************/

    friend SCStream& operator<<(SCStream &, const pcs_application_loadgenerator &);

    /**************************************************************************
     * Implementierungsmethode
     *************************************************************************/

    void Body(void);

    /**************************************************************************
     * Lokale Variablen des Prozesses
     *************************************************************************/

    SCInteger v_sp;
    SCInteger v_dp;
    SCInteger v_da;
    SCInteger v_name;
    SCInteger v_len;
    SCInteger v_prec;
    SCInteger v_sec;
    SCInteger v_descr;
    SCInteger v_tout;
    SCInteger v_aaa;
    SCInteger v_aar;
    SCInteger v_rcv_wnd;
    SCInteger v_snd_wnd;
    SCInteger v_open;
    SCInteger v_send_to;
    SCBoolean v_urg;
    DataType_traceblockstructure v_trace_block;
    DataType_addressid v_address;
    SCInteger v_counter;

    /**************************************************************************
     * Formale Parameter des Prozesses
     *************************************************************************/

    SCInteger v_addr;

    /**************************************************************************
     * IDs der Zustandstypen des Prozesses
     *************************************************************************/

    enum
    {
      state_type_id_start = kSCStateTypeIDBase + 0,
      state_type_id_makeconnection1,
      state_type_id_makeconnection2,
      state_type_id_waitforid1,
      state_type_id_waitforid2,
      state_type_id_waitcompletion,
      state_type_id_connected,
      state_type_id_waitdisconnection,
      state_type_id_makeconnection1_dec_1_answ,
      state_type_id_makeconnection1_dec_1_tail,
      state_type_id_makeconnection2_dec_1_answ,
      state_type_id_makeconnection2_dec_1_tail,
      state_type_id_connected_dec_1_answ,
      state_type_id_connected_dec_1_tail
    };

    /**************************************************************************
     * Zustandstypen des Prozesses (statisch)
     *************************************************************************/

    static SCStateType * state_type_start;
    static SCStateType * state_type_makeconnection1;
    static SCStateType * state_type_makeconnection2;
    static SCStateType * state_type_waitforid1;
    static SCStateType * state_type_waitforid2;
    static SCStateType * state_type_waitcompletion;
    static SCStateType * state_type_connected;
    static SCStateType * state_type_waitdisconnection;
    static SCStateType * state_type_makeconnection1_dec_1_answ;
    static SCStateType * state_type_makeconnection1_dec_1_tail;
    static SCStateType * state_type_makeconnection2_dec_1_answ;
    static SCStateType * state_type_makeconnection2_dec_1_tail;
    static SCStateType * state_type_connected_dec_1_answ;
    static SCStateType * state_type_connected_dec_1_tail;

    /**************************************************************************
     * Input-Sets der Transitionen des Prozesses (statisch)
     *************************************************************************/

    static SCSignalID input_set_makeconnection1_transition0[];
    static SCSignalID input_set_makeconnection2_transition0[];
    static SCSignalID input_set_waitforid1_transition0[];
    static SCSignalID input_set_waitforid1_transition1[];
    static SCSignalID input_set_waitforid1_transition2[];
    static SCSignalID input_set_waitforid2_transition0[];
    static SCSignalID input_set_waitforid2_transition1[];
    static SCSignalID input_set_waitforid2_transition2[];
    static SCSignalID input_set_waitcompletion_transition0[];
    static SCSignalID input_set_waitcompletion_transition1[];
    static SCSignalID input_set_waitcompletion_transition2[];
    static SCSignalID input_set_waitcompletion_transition3[];
    static SCSignalID input_set_waitcompletion_transition4[];
    static SCSignalID input_set_connected_transition0[];
    static SCSignalID input_set_connected_transition1[];
    static SCSignalID input_set_connected_transition2[];
    static SCSignalID input_set_connected_transition3[];
    static SCSignalID input_set_connected_transition4[];
    static SCSignalID input_set_connected_transition5[];
    static SCSignalID input_set_waitdisconnection_transition0[];
    static SCSignalID input_set_waitdisconnection_transition1[];
    static SCSignalID input_set_waitdisconnection_transition2[];
    static SCSignalID input_set_waitdisconnection_transition3[];

    /**************************************************************************
     * Save-Sets der Zustaende des Prozesses (statisch)
     *************************************************************************/


    /**************************************************************************
     * Standardvariablen zur Prozesssteuerung
     *************************************************************************/

    SCInteger v_cur_state;
    SCInteger v_transition_id;
    SCTransition *v_transition;
    SCSignalType *v_signal_read;

};

#endif
