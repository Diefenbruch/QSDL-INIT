/******************************************************************************
 *                            pcs_medium_transport.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"
#include "pcs_medium_transport.h"


#include <SCL/SCScheduler.h>
#include <SCL/SCTransition.h>

/******************************************************************************
 * Signaltypen der SDL-Timer auf Prozessebene (statisch)
 *****************************************************************************/

pcs_medium_transport::TimType_delay_finished * pcs_medium_transport_data::tim_type_delay_finished = NULL;

/******************************************************************************
 * Typen der SDL-Zustaende auf Prozessebene (statisch)
 *****************************************************************************/

SCStateType * pcs_medium_transport::state_type_start = NULL;
SCStateType * pcs_medium_transport::state_type_ready = NULL;

/******************************************************************************
 * Input-Sets der Prozesstransitionen (statisch)
 *****************************************************************************/

SCSignalID pcs_medium_transport::input_set_ready_transition0[] =
{
  sig_type_id_ip_packet
};

/******************************************************************************
 * Initialisierungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

SCBoolean pcs_medium_transport_data::Initialize(void)
{
  SCBoolean result = true;

  if (SCScheduler::IsVerbose())
  {
    SCScheduler::outputStream << "Initializing process transport..." << std::endl;
  }

  /****************************************************************************
   * Timertypen der SDL-Timer initialisieren:
   ***************************************************************************/

  tim_type_delay_finished = new TimType_delay_finished(tim_type_id_delay_finished,
                                                       "delay_finished");


  return result;
}

SCBoolean pcs_medium_transport::Initialize(void)
{
  SCNatural i;
  SCProcessID id;
  SCTransition *v_transition;
  SCBoolean result = true;

  /****************************************************************************
   * Initialisierung aller Zustaende des Prozesstyps:
   ***************************************************************************/

  state_type_start = new SCStateType(state_type_id_start, "start");
  state_type_ready = new SCStateType(state_type_id_ready, "ready",
                                     0, NULL, false, false,
                                     pcs_type_transport);

  /****************************************************************************
   * Initialisierung aller Transitionen des Prozesstyps:
   ***************************************************************************/

  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_start,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_ready,
                                  sizeof(input_set_ready_transition0) / sizeof(SCSignalID),
                                  input_set_ready_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);

  /****************************************************************************
   * Initiale Anzahl von Prozessinstanzen erzeugen:
   ***************************************************************************/

  for (i = 0; i < 1; i++)
  {
    id = SCScheduler::Create(pcs_type_transport);
    assert(id != kSCNoProcessID);
  }

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

void pcs_medium_transport_data::Finish(void)
{
  /****************************************************************************
   * Timertypen der SDL-Timer zerstoeren:
   ***************************************************************************/

  delete tim_type_delay_finished;

}

void pcs_medium_transport::Finish(void)
{
  /****************************************************************************
   * Zustandstypen der Prozess-Zustaende zerstoeren:
   ***************************************************************************/

  delete state_type_start;
  delete state_type_ready;

}

/******************************************************************************
 * Konstruktoren
 *****************************************************************************/

pcs_medium_transport_data::pcs_medium_transport_data(void)
{
}

pcs_medium_transport::pcs_medium_transport(const SCProcessID creator,
                                           const SCProcessType *proc_type) : 
  SCProcess(creator, proc_type, state_type_start, NULL, false)
{
#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Creating " << *this << std::endl;
  }

  /****************************************************************************
   * Variableninitialisierung:
   ***************************************************************************/

  v_packet_nr = 0;
  v_packets = 0;

  /****************************************************************************
   * Aktuellen Zustand auf Startzustand setzen:
   ***************************************************************************/

  v_cur_state = state_type_id_start;

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

pcs_medium_transport::pcs_medium_transport(SCMem &save_area) : 
  SCProcess(false, (SCObject *)NULL)
{
  Restore(save_area);

#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Recreated " << *this << std::endl;
  }

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

pcs_medium_transport_data::~pcs_medium_transport_data(void)
{
}

pcs_medium_transport::~pcs_medium_transport(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Deleting " << *this << std::endl;
  }
}

/******************************************************************************
 * Implementierungsfunktion des SDL-Prozesses
 *****************************************************************************/

void pcs_medium_transport::Body(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Executing " << *this << std::endl;
  }

  /****************************************************************************
   * Hauptschleife:
   ***************************************************************************/

  nextstate:
  v_transition_id = kSCNoTransition;
  backtracking:
  while(true)
  {
    switch(v_cur_state)
    {
      /************************************************************************
       * Starttransition:
       ***********************************************************************/

      case state_type_id_start:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_start, kSCNoAwakeDelay,
                                  &v_signal_read);
        }
        v_packets = 0;
        v_cur_state = state_type_id_ready;
        goto nextstate;

      /************************************************************************
       * Zustand 'ready':
       ***********************************************************************/

      case state_type_id_ready:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_ready, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_ready)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_ip_packet:
              sigparam_ip_packet = (SigParam_ip_packet *)RetrieveInputData();
              assert(sigparam_ip_packet);
              v_ip_in = sigparam_ip_packet->sig_field_1;
              delete sigparam_ip_packet;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'ready'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): ip_packet
            switch (Decision(2, v_ip_in.field_dst == syn_server_a_address,
                             v_ip_in.field_dst == syn_server_b_address))
            {
              case kSCDecisionBase + 0:
                sigparam_ip_packet = new SigParam_ip_packet;
                assert(sigparam_ip_packet);
                sigparam_ip_packet->sig_field_1 = v_ip_in;
                Output(blk_ip::pcs_type_activity, sig_type_ip_packet,
                       sigparam_ip_packet);
                break;
              case kSCDecisionBase + 1:
                break;
              default:
                std::cerr << "Not specified decision value!" <<
                             std::endl;
                break;
            }
            v_cur_state = state_type_id_ready;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'ready': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      default:
        std::cerr << "Process 'transport': Invalid process state." <<
                     std::endl;
        break;
    }
  }
}

/******************************************************************************
 * Save-Methode zur Speicherung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_medium_transport::Save(SCMem &save_area) const
{
  /****************************************************************************
   * Speicherung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Save(save_area);

  /****************************************************************************
   * Sicherung der Variablen:
   ***************************************************************************/

  v_ip_in.Save(save_area);
  save_area.Store(&v_packet_nr, sizeof(SCInteger));
  save_area.Store(&v_packets, sizeof(SCInteger));

  /****************************************************************************
   * Speicherung der Zustandsvariablen
   ***************************************************************************/

  save_area.Store(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_medium_transport::Restore(SCMem &save_area)
{
  /****************************************************************************
   * Restaurierung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Restore(save_area);

  /****************************************************************************
   * Restaurierung der Variablen:
   ***************************************************************************/

  v_ip_in.Restore(save_area);
  save_area.Restore(&v_packet_nr, sizeof(SCInteger));
  save_area.Restore(&v_packets, sizeof(SCInteger));

  /****************************************************************************
   * Restaurierung der Zustandsvariablen
   ***************************************************************************/

  save_area.Restore(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz
 *****************************************************************************/

void pcs_medium_transport::Size(SCSize *cur_size) const
{
  /****************************************************************************
   * Berechnung der Groesse der Basisklasse
   ***************************************************************************/

  SCProcess::Size(cur_size);

  /****************************************************************************
   * Berechnung der Variablengroessen:
   ***************************************************************************/

  v_ip_in.Size(cur_size);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);

  /****************************************************************************
   * Groesse der Zustandsvariablen
   ***************************************************************************/

  cur_size->size += sizeof(v_cur_state);

}

/******************************************************************************
 * Display-Methode
 *****************************************************************************/

SCStream& operator<<(SCStream &out, const pcs_medium_transport &me)
{
  return me.Display(out);
}
