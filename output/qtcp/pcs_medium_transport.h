/******************************************************************************
 *                            pcs_medium_transport.h
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef _PCS_MEDIUM_TRANSPORT_H_
#define _PCS_MEDIUM_TRANSPORT_H_

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_medium.h"

#include <SCL/SCProcess.h>
#include <SCL/SCStateType.h>
#include <SCL/SCTimerType.h>
#include <SCL/SCProcedureType.h>

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'transport' (Data)
 *****************************************************************************/

class pcs_medium_transport_data : public blk_medium
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktor
     *************************************************************************/

    pcs_medium_transport_data(void);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_medium_transport_data(void);

    /**************************************************************************
     * IDs der Timertypen auf Prozessebene
     *************************************************************************/

    enum
    {
      tim_type_id_delay_finished = kSCSignalTypeIDBase + 28
    };

    /**************************************************************************
     * Strukturen fuer die Timerparameter
     *************************************************************************/

    struct TimParam_delay_finished : public SCDataType
    {
      // Default Konstruktor:
      TimParam_delay_finished(void)
      {
        tim_field_1 = 0;
      }
      // Copy Konstruktor:
      TimParam_delay_finished(const TimParam_delay_finished& orig)
      {
        *this = orig;
      }
      integer tim_field_1;
      // Virtueller Clone-Operator:
      SCDataType *Clone(void) const
      {
        return new TimParam_delay_finished(*this);
      }
      // Zuweisungsoperator:
      TimParam_delay_finished& operator= (const TimParam_delay_finished &orig)
      {
        tim_field_1 = orig.tim_field_1;
        return *this;
      }
      // Vergleichsoperator:
      SCBoolean operator== (const TimParam_delay_finished &second) const
      {
        return (tim_field_1 == second.tim_field_1);
      }
      // Virtueller Vergleichssoperator:
      SCBoolean Equal(const SCDataType &second) const
      {
        return (*this == *(TimParam_delay_finished *)&second);
      }
      // Ausgabeoperator:
      friend SCStream& operator<<(SCStream &out, const TimParam_delay_finished &me)
      {
        out << me.tim_field_1;
        return out;
      }
      // Virtueller Ausgabeoperator:
      SCStream& Display(SCStream &out) const
      {
        return (out << *this);
      }
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(&tim_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(&tim_field_1, sizeof(SCInteger));
        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += sizeof(SCInteger);
      }
    };

    /**************************************************************************
     * Variablen fuer die Timerparameter
     *************************************************************************/

    TimParam_delay_finished *timparam_delay_finished;

    /**************************************************************************
     * Timertypen auf Prozessebene (statisch)
     *************************************************************************/

    struct TimType_delay_finished: public SCTimerType
    {
      TimType_delay_finished(SCNatural type_key, const char *type_name) :
        SCTimerType(type_key, type_name)
      {
      }
      SCDataType *NewData(void) const
      {
        return new TimParam_delay_finished;
      }
    };
    static TimType_delay_finished * tim_type_delay_finished;

};

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'transport' (Instanz)
 *****************************************************************************/

class pcs_medium_transport : public SCProcess, public pcs_medium_transport_data
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktoren
     *************************************************************************/

    pcs_medium_transport(const SCProcessID, const SCProcessType *);
    pcs_medium_transport(SCMem &);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_medium_transport(void);

    /**************************************************************************
     * Virtuelle Save- & Restore-Methoden
     *************************************************************************/

    SCBoolean Save(SCMem &) const;
    SCBoolean Restore(SCMem &);

    /**************************************************************************
     * Virtuelle Size-Methode
     *************************************************************************/

    void Size(SCSize *) const;

    /**************************************************************************
     * Display-Methoden
     *************************************************************************/

    friend SCStream& operator<<(SCStream &, const pcs_medium_transport &);

    /**************************************************************************
     * Implementierungsmethode
     *************************************************************************/

    void Body(void);

    /**************************************************************************
     * Lokale Variablen des Prozesses
     *************************************************************************/

    DataType_ip v_ip_in;
    SCInteger v_packet_nr;
    SCInteger v_packets;

    /**************************************************************************
     * IDs der Zustandstypen des Prozesses
     *************************************************************************/

    enum
    {
      state_type_id_start = kSCStateTypeIDBase + 32,
      state_type_id_ready
    };

    /**************************************************************************
     * Zustandstypen des Prozesses (statisch)
     *************************************************************************/

    static SCStateType * state_type_start;
    static SCStateType * state_type_ready;

    /**************************************************************************
     * Input-Sets der Transitionen des Prozesses (statisch)
     *************************************************************************/

    static SCSignalID input_set_ready_transition0[];

    /**************************************************************************
     * Standardvariablen zur Prozesssteuerung
     *************************************************************************/

    SCInteger v_cur_state;
    SCInteger v_transition_id;
    SCTransition *v_transition;
    SCSignalType *v_signal_read;

};

#endif
