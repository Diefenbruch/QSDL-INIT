/******************************************************************************
 *                            pcs_tcp_manager.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"
#include "pcs_tcp_manager.h"
#include "pcs_tcp_port.h"


#include <SCL/SCScheduler.h>
#include <SCL/SCTransition.h>

/******************************************************************************
 * Konstanten (Synonyme) auf Prozessebene (statisch)
 *****************************************************************************/

SCInteger pcs_tcp_manager_data::syn_error_no_free_port;
SCInteger pcs_tcp_manager_data::syn_undefined_destinationport;
SCInteger pcs_tcp_manager_data::syn_undefined_destinationaddress;

/******************************************************************************
 * Typen der SDL-Zustaende auf Prozessebene (statisch)
 *****************************************************************************/

SCStateType * pcs_tcp_manager::state_type_start = NULL;
SCStateType * pcs_tcp_manager::state_type_waitforinput = NULL;

/******************************************************************************
 * Input-Sets der Prozesstransitionen (statisch)
 *****************************************************************************/

SCSignalID pcs_tcp_manager::input_set_waitforinput_transition0[] =
{
  sig_type_id_upo
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition1[] =
{
  sig_type_id_fspo
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition2[] =
{
  sig_type_id_ao
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition3[] =
{
  sig_type_id_aod
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition4[] =
{
  sig_type_id_send
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition5[] =
{
  sig_type_id_allocate
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition6[] =
{
  sig_type_id_del
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition7[] =
{
  sig_type_id_ter
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition8[] =
{
  sig_type_id_err
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition9[] =
{
  sig_type_id_stresp
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition10[] =
{
  sig_type_id_closing
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition11[] =
{
  sig_type_id_os
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition12[] =
{
  sig_type_id_of
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition13[] =
{
  sig_type_id_abort
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition14[] =
{
  sig_type_id_close
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition15[] =
{
  sig_type_id_status
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition16[] =
{
  sig_type_id_tcp_packet
};
SCSignalID pcs_tcp_manager::input_set_waitforinput_transition17[] =
{
  sig_type_id_process_terminated
};

/******************************************************************************
 * Initialisierungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

SCBoolean pcs_tcp_manager_data::Initialize(void)
{
  SCBoolean result = true;

  if (SCScheduler::IsVerbose())
  {
    SCScheduler::outputStream << "Initializing process manager..." << std::endl;
  }

  /****************************************************************************
   * Datentypen auf Prozessebene initialisieren:
   ***************************************************************************/

  syn_error_no_free_port = 0;
  syn_undefined_destinationport =  -1;
  syn_undefined_destinationaddress =  -1;


  return result;
}

SCBoolean pcs_tcp_manager::Initialize(void)
{
  SCNatural i;
  SCProcessID id;
  SCTransition *v_transition;
  SCBoolean result = true;

  /****************************************************************************
   * Initialisierung aller Zustaende des Prozesstyps:
   ***************************************************************************/

  state_type_start = new SCStateType(state_type_id_start, "start");
  state_type_waitforinput = new SCStateType(state_type_id_waitforinput,
                                            "waitforinput",
                                            0, NULL, false,
                                            false, pcs_type_manager);

  /****************************************************************************
   * Initialisierung aller Transitionen des Prozesstyps:
   ***************************************************************************/

  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_start,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition0) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition1) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition2) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition3) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition4) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 5, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition5) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition5,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 6, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition6) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition6,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 7, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition7) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition7,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 8, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition8) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition8,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 9, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition9) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition9,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 10, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition10) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition10,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 11, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition11) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition11,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 12, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition12) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition12,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 13, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition13) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition13,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 14, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition14) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition14,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 15, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition15) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition15,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 16, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition16) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition16,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 17, state_type_waitforinput,
                                  sizeof(input_set_waitforinput_transition17) / sizeof(SCSignalID),
                                  input_set_waitforinput_transition17,
                                  kSCPrioNormalInput);
  assert(v_transition);

  /****************************************************************************
   * Initiale Anzahl von Prozessinstanzen erzeugen:
   ***************************************************************************/

  for (i = 0; i < 1; i++)
  {
    id = SCScheduler::Create(pcs_type_manager);
    assert(id != kSCNoProcessID);
  }

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

void pcs_tcp_manager_data::Finish(void)
{
}

void pcs_tcp_manager::Finish(void)
{
  /****************************************************************************
   * Zustandstypen der Prozess-Zustaende zerstoeren:
   ***************************************************************************/

  delete state_type_start;
  delete state_type_waitforinput;

}

/******************************************************************************
 * Konstruktoren
 *****************************************************************************/

pcs_tcp_manager_data::pcs_tcp_manager_data(void)
{
}

pcs_tcp_manager::pcs_tcp_manager(const SCProcessID creator, const SCProcessType *proc_type) : 
  SCProcess(creator, proc_type, state_type_start, NULL, false)
{
#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Creating " << *this << std::endl;
  }

  /****************************************************************************
   * Variableninitialisierung:
   ***************************************************************************/

  v_sp = 0;
  v_dp = 0;
  v_da = 0;
  v_tout = 0;
  v_toa = 0;
  v_prec = 0;
  v_sec = 0;
  v_len = 0;
  v_rcv_wnd = 0;
  v_snd_wnd = 0;
  v_name = 0;
  v_descr = 0;
  v_aaa = 0;
  v_aar = 0;
  v_run = 0;
  v_urg = false;
  v_psh = false;
  v_ok = false;

  /****************************************************************************
   * Aktuellen Zustand auf Startzustand setzen:
   ***************************************************************************/

  v_cur_state = state_type_id_start;

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

pcs_tcp_manager::pcs_tcp_manager(SCMem &save_area) : 
  SCProcess(false, (SCObject *)NULL)
{
  Restore(save_area);

#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Recreated " << *this << std::endl;
  }

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

pcs_tcp_manager_data::~pcs_tcp_manager_data(void)
{
}

pcs_tcp_manager::~pcs_tcp_manager(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Deleting " << *this << std::endl;
  }
}

/******************************************************************************
 * Lokale Prozeduren
 *****************************************************************************/

void pcs_tcp_manager::createport(DataType_portrange v_n, SCBoolean &v_ok)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  switch (v_exist[v_n])
  {
    case false:
      Create(pcs_type_port);
      v_port_addr[v_n] = Offspring();
      v_ok = true;
      v_exist[v_n] = true;
      return;
      break;
    case true:
      v_ok = false;
      return;
      break;
  }
}

void pcs_tcp_manager::getfreeport(DataType_portrange &v_n)
{
  /****************************************************************************
   * Starttransition:
   ***************************************************************************/

  label_jump1:
  switch (v_exist[v_n] == true)
  {
    case false:
      break;
    case true:
      v_n = v_n + 1;
      goto label_jump1;
      break;
  }
  return;
}


/******************************************************************************
 * Implementierungsfunktion des SDL-Prozesses
 *****************************************************************************/

void pcs_tcp_manager::Body(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Executing " << *this << std::endl;
  }

  /****************************************************************************
   * Hauptschleife:
   ***************************************************************************/

  nextstate:
  v_transition_id = kSCNoTransition;
  backtracking:
  while(true)
  {
    switch(v_cur_state)
    {
      /************************************************************************
       * Starttransition:
       ***********************************************************************/

      case state_type_id_start:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_start, kSCNoAwakeDelay,
                                  &v_signal_read);
        }
        v_run = 0;
        label_jump1:
        v_exist[v_run] = false;
        switch (v_run == syn_max_connections)
        {
          case false:
            v_run = v_run + 1;
            goto label_jump1;
            break;
          case true:
            break;
        }
        v_cur_state = state_type_id_waitforinput;
        goto nextstate;

      /************************************************************************
       * Zustand 'waitforinput':
       ***********************************************************************/

      case state_type_id_waitforinput:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitforinput, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_waitforinput)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_upo:
              sigparam_upo = (SigParam_upo *)RetrieveInputData();
              assert(sigparam_upo);
              v_sp = sigparam_upo->sig_field_1;
              v_tout = sigparam_upo->sig_field_2;
              v_toa = sigparam_upo->sig_field_3;
              v_prec = sigparam_upo->sig_field_4;
              v_sec = sigparam_upo->sig_field_5;
              delete sigparam_upo;
              break;

            case sig_type_id_fspo:
              sigparam_fspo = (SigParam_fspo *)RetrieveInputData();
              assert(sigparam_fspo);
              v_sp = sigparam_fspo->sig_field_1;
              v_dp = sigparam_fspo->sig_field_2;
              v_da = sigparam_fspo->sig_field_3;
              v_tout = sigparam_fspo->sig_field_4;
              v_toa = sigparam_fspo->sig_field_5;
              v_prec = sigparam_fspo->sig_field_6;
              v_sec = sigparam_fspo->sig_field_7;
              delete sigparam_fspo;
              break;

            case sig_type_id_ao:
              sigparam_ao = (SigParam_ao *)RetrieveInputData();
              assert(sigparam_ao);
              v_sp = sigparam_ao->sig_field_1;
              v_dp = sigparam_ao->sig_field_2;
              v_da = sigparam_ao->sig_field_3;
              v_tout = sigparam_ao->sig_field_4;
              v_toa = sigparam_ao->sig_field_5;
              v_prec = sigparam_ao->sig_field_6;
              v_sec = sigparam_ao->sig_field_7;
              delete sigparam_ao;
              break;

            case sig_type_id_aod:
              sigparam_aod = (SigParam_aod *)RetrieveInputData();
              assert(sigparam_aod);
              v_sp = sigparam_aod->sig_field_1;
              v_dp = sigparam_aod->sig_field_2;
              v_da = sigparam_aod->sig_field_3;
              v_tout = sigparam_aod->sig_field_4;
              v_toa = sigparam_aod->sig_field_5;
              v_prec = sigparam_aod->sig_field_6;
              v_sec = sigparam_aod->sig_field_7;
              v_len = sigparam_aod->sig_field_8;
              v_psh = sigparam_aod->sig_field_9;
              v_urg = sigparam_aod->sig_field_10;
              delete sigparam_aod;
              break;

            case sig_type_id_send:
              sigparam_send = (SigParam_send *)RetrieveInputData();
              assert(sigparam_send);
              v_name = sigparam_send->sig_field_1;
              v_len = sigparam_send->sig_field_2;
              v_psh = sigparam_send->sig_field_3;
              v_urg = sigparam_send->sig_field_4;
              v_tout = sigparam_send->sig_field_5;
              v_toa = sigparam_send->sig_field_6;
              delete sigparam_send;
              break;

            case sig_type_id_allocate:
              sigparam_allocate = (SigParam_allocate *)RetrieveInputData();
              assert(sigparam_allocate);
              v_name = sigparam_allocate->sig_field_1;
              v_len = sigparam_allocate->sig_field_2;
              delete sigparam_allocate;
              break;

            case sig_type_id_del:
              sigparam_del = (SigParam_del *)RetrieveInputData();
              assert(sigparam_del);
              v_name = sigparam_del->sig_field_1;
              v_len = sigparam_del->sig_field_2;
              v_urg = sigparam_del->sig_field_3;
              delete sigparam_del;
              break;

            case sig_type_id_ter:
              sigparam_ter = (SigParam_ter *)RetrieveInputData();
              assert(sigparam_ter);
              v_name = sigparam_ter->sig_field_1;
              v_descr = sigparam_ter->sig_field_2;
              delete sigparam_ter;
              break;

            case sig_type_id_err:
              sigparam_err = (SigParam_err *)RetrieveInputData();
              assert(sigparam_err);
              v_name = sigparam_err->sig_field_1;
              v_descr = sigparam_err->sig_field_2;
              delete sigparam_err;
              break;

            case sig_type_id_stresp:
              sigparam_stresp = (SigParam_stresp *)RetrieveInputData();
              assert(sigparam_stresp);
              v_name = sigparam_stresp->sig_field_1;
              v_dp = sigparam_stresp->sig_field_2;
              v_da = sigparam_stresp->sig_field_3;
              v_rcv_wnd = sigparam_stresp->sig_field_4;
              v_snd_wnd = sigparam_stresp->sig_field_5;
              v_aaa = sigparam_stresp->sig_field_6;
              v_aar = sigparam_stresp->sig_field_7;
              v_urg = sigparam_stresp->sig_field_8;
              v_prec = sigparam_stresp->sig_field_9;
              v_sec = sigparam_stresp->sig_field_10;
              v_tout = sigparam_stresp->sig_field_11;
              delete sigparam_stresp;
              break;

            case sig_type_id_closing:
              sigparam_closing = (SigParam_closing *)RetrieveInputData();
              assert(sigparam_closing);
              v_name = sigparam_closing->sig_field_1;
              delete sigparam_closing;
              break;

            case sig_type_id_os:
              sigparam_os = (SigParam_os *)RetrieveInputData();
              assert(sigparam_os);
              v_name = sigparam_os->sig_field_1;
              delete sigparam_os;
              break;

            case sig_type_id_of:
              sigparam_of = (SigParam_of *)RetrieveInputData();
              assert(sigparam_of);
              v_name = sigparam_of->sig_field_1;
              delete sigparam_of;
              break;

            case sig_type_id_abort:
              sigparam_abort = (SigParam_abort *)RetrieveInputData();
              assert(sigparam_abort);
              v_name = sigparam_abort->sig_field_1;
              delete sigparam_abort;
              break;

            case sig_type_id_close:
              sigparam_close = (SigParam_close *)RetrieveInputData();
              assert(sigparam_close);
              v_name = sigparam_close->sig_field_1;
              delete sigparam_close;
              break;

            case sig_type_id_status:
              sigparam_status = (SigParam_status *)RetrieveInputData();
              assert(sigparam_status);
              v_name = sigparam_status->sig_field_1;
              delete sigparam_status;
              break;

            case sig_type_id_tcp_packet:
              sigparam_tcp_packet = (SigParam_tcp_packet *)RetrieveInputData();
              assert(sigparam_tcp_packet);
              v_tcp_in = sigparam_tcp_packet->sig_field_1;
              delete sigparam_tcp_packet;
              break;

            case sig_type_id_process_terminated:
              sigparam_process_terminated = (SigParam_process_terminated *)RetrieveInputData();
              assert(sigparam_process_terminated);
              v_name = sigparam_process_terminated->sig_field_1;
              delete sigparam_process_terminated;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitforinput'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): upo
            v_n = 1;
            getfreeport(v_n);
            switch (v_n > syn_max_connections)
            {
              case true:
                sigparam_of = new SigParam_of;
                assert(sigparam_of);
                sigparam_of->sig_field_1 = syn_error_no_free_port;
                Output(blk_application::pcs_type_loadgenerator,
                       sig_type_of, sigparam_of);
                v_cur_state = state_type_id_waitforinput;
                goto nextstate;
                break;
              case false:
                break;
            }
            createport(v_n, v_ok);
            v_appl_addr[v_n] = Sender();
            sigparam_upo = new SigParam_upo;
            assert(sigparam_upo);
            sigparam_upo->sig_field_1 = v_n;
            sigparam_upo->sig_field_2 = v_tout;
            sigparam_upo->sig_field_3 = v_toa;
            sigparam_upo->sig_field_4 = v_prec;
            sigparam_upo->sig_field_5 = v_sec;
            Output(v_port_addr[v_n], sig_type_upo, sigparam_upo);
            sigparam_oid = new SigParam_oid;
            assert(sigparam_oid);
            sigparam_oid->sig_field_1 = v_n;
            sigparam_oid->sig_field_2 = v_n;
            sigparam_oid->sig_field_3 = syn_undefined_destinationport;
            sigparam_oid->sig_field_4 = syn_undefined_destinationaddress - 1;
            Output(v_appl_addr[v_n], sig_type_oid, sigparam_oid);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): fspo
            createport(v_sp, v_ok);
            switch (v_ok)
            {
              case false:
                sigparam_of = new SigParam_of;
                assert(sigparam_of);
                sigparam_of->sig_field_1 = v_sp;
                Output(blk_application::pcs_type_loadgenerator,
                       sig_type_of, sigparam_of);
                v_cur_state = state_type_id_waitforinput;
                goto nextstate;
                break;
              case true:
                break;
            }
            sigparam_fspo = new SigParam_fspo;
            assert(sigparam_fspo);
            sigparam_fspo->sig_field_1 = v_sp;
            sigparam_fspo->sig_field_2 = v_dp;
            sigparam_fspo->sig_field_3 = v_da;
            sigparam_fspo->sig_field_4 = v_tout;
            sigparam_fspo->sig_field_5 = v_toa;
            sigparam_fspo->sig_field_6 = v_prec;
            sigparam_fspo->sig_field_7 = v_sec;
            Output(v_port_addr[v_sp], sig_type_fspo, sigparam_fspo);
            v_appl_addr[v_sp] = Sender();
            sigparam_oid = new SigParam_oid;
            assert(sigparam_oid);
            sigparam_oid->sig_field_1 = v_sp;
            sigparam_oid->sig_field_2 = v_sp;
            sigparam_oid->sig_field_3 = v_dp;
            sigparam_oid->sig_field_4 = v_da;
            Output(v_appl_addr[v_sp], sig_type_oid, sigparam_oid);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): ao
            createport(v_sp, v_ok);
            switch (v_ok)
            {
              case false:
                sigparam_of = new SigParam_of;
                assert(sigparam_of);
                sigparam_of->sig_field_1 = v_sp;
                Output(Sender(), sig_type_of, sigparam_of);
                v_cur_state = state_type_id_waitforinput;
                goto nextstate;
                break;
              case true:
                break;
            }
            sigparam_ao = new SigParam_ao;
            assert(sigparam_ao);
            sigparam_ao->sig_field_1 = v_sp;
            sigparam_ao->sig_field_2 = v_dp;
            sigparam_ao->sig_field_3 = v_da;
            sigparam_ao->sig_field_4 = v_tout;
            sigparam_ao->sig_field_5 = v_toa;
            sigparam_ao->sig_field_6 = v_prec;
            sigparam_ao->sig_field_7 = v_sec;
            Output(v_port_addr[v_sp], sig_type_ao, sigparam_ao);
            v_appl_addr[v_sp] = Sender();
            sigparam_oid = new SigParam_oid;
            assert(sigparam_oid);
            sigparam_oid->sig_field_1 = v_sp;
            sigparam_oid->sig_field_2 = v_sp;
            sigparam_oid->sig_field_3 = v_dp;
            sigparam_oid->sig_field_4 = v_da;
            Output(v_appl_addr[v_sp], sig_type_oid, sigparam_oid);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): aod
            createport(v_sp, v_ok);
            switch (v_ok)
            {
              case false:
                sigparam_of = new SigParam_of;
                assert(sigparam_of);
                sigparam_of->sig_field_1 = v_sp;
                Output(Sender(), sig_type_of, sigparam_of);
                v_cur_state = state_type_id_waitforinput;
                goto nextstate;
                break;
              case true:
                break;
            }
            sigparam_aod = new SigParam_aod;
            assert(sigparam_aod);
            sigparam_aod->sig_field_1 = v_sp;
            sigparam_aod->sig_field_2 = v_dp;
            sigparam_aod->sig_field_3 = v_da;
            sigparam_aod->sig_field_4 = v_tout;
            sigparam_aod->sig_field_5 = v_toa;
            sigparam_aod->sig_field_6 = v_prec;
            sigparam_aod->sig_field_7 = v_sec;
            sigparam_aod->sig_field_8 = v_len;
            sigparam_aod->sig_field_9 = v_psh;
            sigparam_aod->sig_field_10 = v_urg;
            Output(v_port_addr[v_sp], sig_type_aod, sigparam_aod);
            v_appl_addr[v_sp] = Sender();
            sigparam_oid = new SigParam_oid;
            assert(sigparam_oid);
            sigparam_oid->sig_field_1 = v_sp;
            sigparam_oid->sig_field_2 = v_sp;
            sigparam_oid->sig_field_3 = v_dp;
            sigparam_oid->sig_field_4 = v_da;
            Output(v_appl_addr[v_sp], sig_type_oid, sigparam_oid);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): send
            switch (v_exist[v_name])
            {
              case true:
                sigparam_send = new SigParam_send;
                assert(sigparam_send);
                sigparam_send->sig_field_1 = v_name;
                sigparam_send->sig_field_2 = v_len;
                sigparam_send->sig_field_3 = v_psh;
                sigparam_send->sig_field_4 = v_urg;
                sigparam_send->sig_field_5 = v_tout;
                sigparam_send->sig_field_6 = v_toa;
                Output(v_port_addr[v_name], sig_type_send, sigparam_send);
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 5: // Input signal(s): allocate
            switch (v_exist[v_name])
            {
              case true:
                sigparam_allocate = new SigParam_allocate;
                assert(sigparam_allocate);
                sigparam_allocate->sig_field_1 = v_name;
                sigparam_allocate->sig_field_2 = v_len;
                Output(v_port_addr[v_name], sig_type_allocate,
                       sigparam_allocate);
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 6: // Input signal(s): del
            sigparam_del = new SigParam_del;
            assert(sigparam_del);
            sigparam_del->sig_field_1 = v_name;
            sigparam_del->sig_field_2 = v_len;
            sigparam_del->sig_field_3 = v_urg;
            Output(v_appl_addr[v_name], sig_type_del, sigparam_del);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 7: // Input signal(s): ter
            sigparam_ter = new SigParam_ter;
            assert(sigparam_ter);
            sigparam_ter->sig_field_1 = v_name;
            sigparam_ter->sig_field_2 = v_descr;
            Output(v_appl_addr[v_name], sig_type_ter, sigparam_ter);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 8: // Input signal(s): err
            sigparam_err = new SigParam_err;
            assert(sigparam_err);
            sigparam_err->sig_field_1 = v_name;
            sigparam_err->sig_field_2 = v_descr;
            Output(v_appl_addr[v_name], sig_type_err, sigparam_err);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 9: // Input signal(s): stresp
            sigparam_stresp = new SigParam_stresp;
            assert(sigparam_stresp);
            sigparam_stresp->sig_field_1 = v_name;
            sigparam_stresp->sig_field_2 = v_dp;
            sigparam_stresp->sig_field_3 = v_da;
            sigparam_stresp->sig_field_4 = v_rcv_wnd;
            sigparam_stresp->sig_field_5 = v_snd_wnd;
            sigparam_stresp->sig_field_6 = v_aaa;
            sigparam_stresp->sig_field_7 = v_aar;
            sigparam_stresp->sig_field_8 = v_urg;
            sigparam_stresp->sig_field_9 = v_prec;
            sigparam_stresp->sig_field_10 = v_sec;
            sigparam_stresp->sig_field_11 = v_tout;
            Output(v_appl_addr[v_name], sig_type_stresp, sigparam_stresp);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 10: // Input signal(s): closing
            sigparam_closing = new SigParam_closing;
            assert(sigparam_closing);
            sigparam_closing->sig_field_1 = v_name;
            Output(v_appl_addr[v_name], sig_type_closing, sigparam_closing);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 11: // Input signal(s): os
            sigparam_os = new SigParam_os;
            assert(sigparam_os);
            sigparam_os->sig_field_1 = v_name;
            Output(v_appl_addr[v_name], sig_type_os, sigparam_os);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 12: // Input signal(s): of
            sigparam_of = new SigParam_of;
            assert(sigparam_of);
            sigparam_of->sig_field_1 = v_name;
            Output(v_appl_addr[v_name], sig_type_of, sigparam_of);
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 13: // Input signal(s): abort
            switch (v_exist[v_name])
            {
              case true:
                sigparam_abort = new SigParam_abort;
                assert(sigparam_abort);
                sigparam_abort->sig_field_1 = v_name;
                Output(v_port_addr[v_name], sig_type_abort, sigparam_abort);
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 14: // Input signal(s): close
            switch (v_exist[v_name])
            {
              case true:
                sigparam_close = new SigParam_close;
                assert(sigparam_close);
                sigparam_close->sig_field_1 = v_name;
                Output(v_port_addr[v_name], sig_type_close, sigparam_close);
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 15: // Input signal(s): status
            switch (v_exist[v_name])
            {
              case true:
                sigparam_status = new SigParam_status;
                assert(sigparam_status);
                sigparam_status->sig_field_1 = v_name;
                Output(v_port_addr[v_name], sig_type_status,
                       sigparam_status);
                break;
              case false:
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 16: // Input signal(s): tcp_packet
            switch (Sender() == v_port_addr[v_tcp_in.field_sp])
            {
              case false:
                switch (v_exist[v_tcp_in.field_dp])
                {
                  case true:
                    sigparam_tcp_packet = new SigParam_tcp_packet;
                    assert(sigparam_tcp_packet);
                    sigparam_tcp_packet->sig_field_1 = v_tcp_in;
                    Output(v_port_addr[v_tcp_in.field_dp], sig_type_tcp_packet,
                           sigparam_tcp_packet);
                    break;
                  case false:
                    break;
                }
                break;
              case true:
                sigparam_tcp_packet = new SigParam_tcp_packet;
                assert(sigparam_tcp_packet);
                sigparam_tcp_packet->sig_field_1 = v_tcp_in;
                Output(blk_ip::pcs_type_activity, sig_type_tcp_packet,
                       sigparam_tcp_packet);
                break;
            }
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 17: // Input signal(s): process_terminated
            v_exist[v_name] = false;
            v_cur_state = state_type_id_waitforinput;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitforinput': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      default:
        std::cerr << "Process 'manager': Invalid process state." <<
                     std::endl;
        break;
    }
  }
}

/******************************************************************************
 * Save-Methode zur Speicherung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_tcp_manager::Save(SCMem &save_area) const
{
  /****************************************************************************
   * Speicherung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Save(save_area);

  /****************************************************************************
   * Sicherung der Variablen:
   ***************************************************************************/

  save_area.Store(&v_sp, sizeof(SCInteger));
  save_area.Store(&v_dp, sizeof(SCInteger));
  save_area.Store(&v_da, sizeof(SCInteger));
  save_area.Store(&v_tout, sizeof(SCInteger));
  save_area.Store(&v_toa, sizeof(SCInteger));
  save_area.Store(&v_prec, sizeof(SCInteger));
  save_area.Store(&v_sec, sizeof(SCInteger));
  save_area.Store(&v_len, sizeof(SCInteger));
  save_area.Store(&v_rcv_wnd, sizeof(SCInteger));
  save_area.Store(&v_snd_wnd, sizeof(SCInteger));
  save_area.Store(&v_name, sizeof(SCInteger));
  save_area.Store(&v_descr, sizeof(SCInteger));
  save_area.Store(&v_aaa, sizeof(SCInteger));
  save_area.Store(&v_aar, sizeof(SCInteger));
  save_area.Store(&v_run, sizeof(SCInteger));
  save_area.Store(&v_urg, sizeof(SCBoolean));
  save_area.Store(&v_psh, sizeof(SCBoolean));
  save_area.Store(&v_ok, sizeof(SCBoolean));
  v_n.Save(save_area);
  v_exist.Save(save_area);
  v_port_addr.Save(save_area);
  v_appl_addr.Save(save_area);
  v_tcp_in.Save(save_area);

  /****************************************************************************
   * Speicherung der Zustandsvariablen
   ***************************************************************************/

  save_area.Store(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_tcp_manager::Restore(SCMem &save_area)
{
  /****************************************************************************
   * Restaurierung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Restore(save_area);

  /****************************************************************************
   * Restaurierung der Variablen:
   ***************************************************************************/

  save_area.Restore(&v_sp, sizeof(SCInteger));
  save_area.Restore(&v_dp, sizeof(SCInteger));
  save_area.Restore(&v_da, sizeof(SCInteger));
  save_area.Restore(&v_tout, sizeof(SCInteger));
  save_area.Restore(&v_toa, sizeof(SCInteger));
  save_area.Restore(&v_prec, sizeof(SCInteger));
  save_area.Restore(&v_sec, sizeof(SCInteger));
  save_area.Restore(&v_len, sizeof(SCInteger));
  save_area.Restore(&v_rcv_wnd, sizeof(SCInteger));
  save_area.Restore(&v_snd_wnd, sizeof(SCInteger));
  save_area.Restore(&v_name, sizeof(SCInteger));
  save_area.Restore(&v_descr, sizeof(SCInteger));
  save_area.Restore(&v_aaa, sizeof(SCInteger));
  save_area.Restore(&v_aar, sizeof(SCInteger));
  save_area.Restore(&v_run, sizeof(SCInteger));
  save_area.Restore(&v_urg, sizeof(SCBoolean));
  save_area.Restore(&v_psh, sizeof(SCBoolean));
  save_area.Restore(&v_ok, sizeof(SCBoolean));
  v_n.Restore(save_area);
  v_exist.Restore(save_area);
  v_port_addr.Restore(save_area);
  v_appl_addr.Restore(save_area);
  v_tcp_in.Restore(save_area);

  /****************************************************************************
   * Restaurierung der Zustandsvariablen
   ***************************************************************************/

  save_area.Restore(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz
 *****************************************************************************/

void pcs_tcp_manager::Size(SCSize *cur_size) const
{
  /****************************************************************************
   * Berechnung der Groesse der Basisklasse
   ***************************************************************************/

  SCProcess::Size(cur_size);

  /****************************************************************************
   * Berechnung der Variablengroessen:
   ***************************************************************************/

  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  cur_size->size += sizeof(SCBoolean);
  v_n.Size(cur_size);
  v_exist.Size(cur_size);
  v_port_addr.Size(cur_size);
  v_appl_addr.Size(cur_size);
  v_tcp_in.Size(cur_size);

  /****************************************************************************
   * Groesse der Zustandsvariablen
   ***************************************************************************/

  cur_size->size += sizeof(v_cur_state);

}

/******************************************************************************
 * Display-Methode
 *****************************************************************************/

SCStream& operator<<(SCStream &out, const pcs_tcp_manager &me)
{
  return me.Display(out);
}
