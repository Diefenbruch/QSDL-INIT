/******************************************************************************
 *                            pcs_application_loadgenerator.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"
#include "pcs_application_loadgenerator.h"
#include "pcs_application_applicationmanager.h"


#include <SCL/SCScheduler.h>
#include <SCL/SCTransition.h>

/******************************************************************************
 * Signaltypen der SDL-Timer auf Prozessebene (statisch)
 *****************************************************************************/

SCTimerType * pcs_application_loadgenerator_data::tim_type_send_init = NULL;
SCTimerType * pcs_application_loadgenerator_data::tim_type_send_fin = NULL;

/******************************************************************************
 * Konstanten (Synonyme) auf Prozessebene (statisch)
 *****************************************************************************/

SCInteger pcs_application_loadgenerator_data::syn_data;
SCInteger pcs_application_loadgenerator_data::syn_port_1;
SCInteger pcs_application_loadgenerator_data::syn_port_2;

/******************************************************************************
 * Save-Sets der Prozesszustaende (statisch)
 *****************************************************************************/


/******************************************************************************
 * Typen der SDL-Zustaende auf Prozessebene (statisch)
 *****************************************************************************/

SCStateType * pcs_application_loadgenerator::state_type_start = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection1 = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection2 = NULL;
SCStateType * pcs_application_loadgenerator::state_type_waitforid1 = NULL;
SCStateType * pcs_application_loadgenerator::state_type_waitforid2 = NULL;
SCStateType * pcs_application_loadgenerator::state_type_waitcompletion = NULL;
SCStateType * pcs_application_loadgenerator::state_type_connected = NULL;
SCStateType * pcs_application_loadgenerator::state_type_waitdisconnection = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection1_dec_1_answ = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection1_dec_1_tail = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection2_dec_1_answ = NULL;
SCStateType * pcs_application_loadgenerator::state_type_makeconnection2_dec_1_tail = NULL;
SCStateType * pcs_application_loadgenerator::state_type_connected_dec_1_answ = NULL;
SCStateType * pcs_application_loadgenerator::state_type_connected_dec_1_tail = NULL;

/******************************************************************************
 * Input-Sets der Prozesstransitionen (statisch)
 *****************************************************************************/

SCSignalID pcs_application_loadgenerator::input_set_makeconnection1_transition0[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_makeconnection2_transition0[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid1_transition0[] =
{
  sig_type_id_oid
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid1_transition1[] =
{
  sig_type_id_of
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid1_transition2[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid2_transition0[] =
{
  sig_type_id_oid
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid2_transition1[] =
{
  sig_type_id_of
};
SCSignalID pcs_application_loadgenerator::input_set_waitforid2_transition2[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_waitcompletion_transition0[] =
{
  sig_type_id_of
};
SCSignalID pcs_application_loadgenerator::input_set_waitcompletion_transition1[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_waitcompletion_transition2[] =
{
  sig_type_id_os
};
SCSignalID pcs_application_loadgenerator::input_set_waitcompletion_transition3[] =
{
  sig_type_id_oid
};
SCSignalID pcs_application_loadgenerator::input_set_waitcompletion_transition4[] =
{
  sig_type_id_del
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition0[] =
{
  sig_type_id_del
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition1[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition2[] =
{
  tim_type_id_send_fin
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition3[] =
{
  sig_type_id_closing
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition4[] =
{
  sig_type_id_err
};
SCSignalID pcs_application_loadgenerator::input_set_connected_transition5[] =
{
  sig_type_id_stresp
};
SCSignalID pcs_application_loadgenerator::input_set_waitdisconnection_transition0[] =
{
  sig_type_id_del
};
SCSignalID pcs_application_loadgenerator::input_set_waitdisconnection_transition1[] =
{
  sig_type_id_err
};
SCSignalID pcs_application_loadgenerator::input_set_waitdisconnection_transition2[] =
{
  tim_type_id_send_init
};
SCSignalID pcs_application_loadgenerator::input_set_waitdisconnection_transition3[] =
{
  sig_type_id_ter
};

/******************************************************************************
 * Initialisierungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

SCBoolean pcs_application_loadgenerator_data::Initialize(void)
{
  SCBoolean result = true;

  if (SCScheduler::IsVerbose())
  {
    SCScheduler::outputStream << "Initializing process loadgenerator..." << std::endl;
  }

  /****************************************************************************
   * Datentypen auf Prozessebene initialisieren:
   ***************************************************************************/

  syn_data = 5000;
  syn_port_1 = 1;
  syn_port_2 = 2;

  /****************************************************************************
   * Timertypen der SDL-Timer initialisieren:
   ***************************************************************************/

  tim_type_send_init = new SCTimerType(tim_type_id_send_init,
                                       "send_init");
  tim_type_send_fin = new SCTimerType(tim_type_id_send_fin, "send_fin");


  return result;
}

SCBoolean pcs_application_loadgenerator::Initialize(void)
{
  SCTransition *v_transition;
  SCBoolean result = true;

  /****************************************************************************
   * Initialisierung aller Zustaende des Prozesstyps:
   ***************************************************************************/

  state_type_start = new SCStateType(state_type_id_start, "start");
  state_type_makeconnection1 = new SCStateType(state_type_id_makeconnection1,
                                               "makeconnection1",
                                               0, NULL, false,
                                               false, pcs_type_loadgenerator);
  state_type_makeconnection2 = new SCStateType(state_type_id_makeconnection2,
                                               "makeconnection2",
                                               0, NULL, false,
                                               false, pcs_type_loadgenerator);
  state_type_waitforid1 = new SCStateType(state_type_id_waitforid1,
                                          "waitforid1", 0, NULL,
                                          false, false, pcs_type_loadgenerator);
  state_type_waitforid2 = new SCStateType(state_type_id_waitforid2,
                                          "waitforid2", 0, NULL,
                                          false, false, pcs_type_loadgenerator);
  state_type_waitcompletion = new SCStateType(state_type_id_waitcompletion,
                                              "waitcompletion",
                                              0, NULL, false,
                                              false, pcs_type_loadgenerator);
  state_type_connected = new SCStateType(state_type_id_connected,
                                         "connected", 0, NULL,
                                         false, false, pcs_type_loadgenerator);
  state_type_waitdisconnection = new SCStateType(state_type_id_waitdisconnection,
                                                 "waitdisconnection",
                                                 0, NULL, false,
                                                 false, pcs_type_loadgenerator);
  state_type_makeconnection1_dec_1_answ = new SCStateType(state_type_id_makeconnection1_dec_1_answ,
                                                          "makeconnection1_dec_1_answ", 0, NULL, true, true, pcs_type_loadgenerator);
  state_type_makeconnection1_dec_1_tail = new SCStateType(state_type_id_makeconnection1_dec_1_tail,
                                                          "makeconnection1_dec_1_tail", 0, NULL, true, true, pcs_type_loadgenerator);
  state_type_makeconnection2_dec_1_answ = new SCStateType(state_type_id_makeconnection2_dec_1_answ,
                                                          "makeconnection2_dec_1_answ", 0, NULL, true, true, pcs_type_loadgenerator);
  state_type_makeconnection2_dec_1_tail = new SCStateType(state_type_id_makeconnection2_dec_1_tail,
                                                          "makeconnection2_dec_1_tail", 0, NULL, true, true, pcs_type_loadgenerator);
  state_type_connected_dec_1_answ = new SCStateType(state_type_id_connected_dec_1_answ,
                                                    "connected_dec_1_answ",
                                                    0, NULL,
                                                    true, true,
                                                    pcs_type_loadgenerator);
  state_type_connected_dec_1_tail = new SCStateType(state_type_id_connected_dec_1_tail,
                                                    "connected_dec_1_tail",
                                                    0, NULL,
                                                    true, true,
                                                    pcs_type_loadgenerator);

  /****************************************************************************
   * Initialisierung aller Transitionen des Prozesstyps:
   ***************************************************************************/

  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_start,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection1,
                                  sizeof(input_set_makeconnection1_transition0) / sizeof(SCSignalID),
                                  input_set_makeconnection1_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection2,
                                  sizeof(input_set_makeconnection2_transition0) / sizeof(SCSignalID),
                                  input_set_makeconnection2_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitforid1,
                                  sizeof(input_set_waitforid1_transition0) / sizeof(SCSignalID),
                                  input_set_waitforid1_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitforid1,
                                  sizeof(input_set_waitforid1_transition1) / sizeof(SCSignalID),
                                  input_set_waitforid1_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_waitforid1,
                                  sizeof(input_set_waitforid1_transition2) / sizeof(SCSignalID),
                                  input_set_waitforid1_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitforid2,
                                  sizeof(input_set_waitforid2_transition0) / sizeof(SCSignalID),
                                  input_set_waitforid2_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitforid2,
                                  sizeof(input_set_waitforid2_transition1) / sizeof(SCSignalID),
                                  input_set_waitforid2_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_waitforid2,
                                  sizeof(input_set_waitforid2_transition2) / sizeof(SCSignalID),
                                  input_set_waitforid2_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitcompletion,
                                  sizeof(input_set_waitcompletion_transition0) / sizeof(SCSignalID),
                                  input_set_waitcompletion_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitcompletion,
                                  sizeof(input_set_waitcompletion_transition1) / sizeof(SCSignalID),
                                  input_set_waitcompletion_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_waitcompletion,
                                  sizeof(input_set_waitcompletion_transition2) / sizeof(SCSignalID),
                                  input_set_waitcompletion_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_waitcompletion,
                                  sizeof(input_set_waitcompletion_transition3) / sizeof(SCSignalID),
                                  input_set_waitcompletion_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_waitcompletion,
                                  sizeof(input_set_waitcompletion_transition4) / sizeof(SCSignalID),
                                  input_set_waitcompletion_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_connected,
                                  sizeof(input_set_connected_transition0) / sizeof(SCSignalID),
                                  input_set_connected_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_connected,
                                  sizeof(input_set_connected_transition1) / sizeof(SCSignalID),
                                  input_set_connected_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_connected,
                                  sizeof(input_set_connected_transition2) / sizeof(SCSignalID),
                                  input_set_connected_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_connected,
                                  sizeof(input_set_connected_transition3) / sizeof(SCSignalID),
                                  input_set_connected_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 4, state_type_connected,
                                  sizeof(input_set_connected_transition4) / sizeof(SCSignalID),
                                  input_set_connected_transition4,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 5, state_type_connected,
                                  sizeof(input_set_connected_transition5) / sizeof(SCSignalID),
                                  input_set_connected_transition5,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_waitdisconnection,
                                  sizeof(input_set_waitdisconnection_transition0) / sizeof(SCSignalID),
                                  input_set_waitdisconnection_transition0,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_waitdisconnection,
                                  sizeof(input_set_waitdisconnection_transition1) / sizeof(SCSignalID),
                                  input_set_waitdisconnection_transition1,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_waitdisconnection,
                                  sizeof(input_set_waitdisconnection_transition2) / sizeof(SCSignalID),
                                  input_set_waitdisconnection_transition2,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 3, state_type_waitdisconnection,
                                  sizeof(input_set_waitdisconnection_transition3) / sizeof(SCSignalID),
                                  input_set_waitdisconnection_transition3,
                                  kSCPrioNormalInput);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection1_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_makeconnection1_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 2, state_type_makeconnection1_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection1_dec_1_tail,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection2_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_makeconnection2_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_makeconnection2_dec_1_tail,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_connected_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 1, state_type_connected_dec_1_answ,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);
  v_transition = new SCTransition(kSCTransitionIDBase + 0, state_type_connected_dec_1_tail,
                                  -1, NULL, kSCPrioInputNone);
  assert(v_transition);

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Prozessklasse (statisch)
 *****************************************************************************/

void pcs_application_loadgenerator_data::Finish(void)
{
  /****************************************************************************
   * Timertypen der SDL-Timer zerstoeren:
   ***************************************************************************/

  delete tim_type_send_init;
  delete tim_type_send_fin;

}

void pcs_application_loadgenerator::Finish(void)
{
  /****************************************************************************
   * Zustandstypen der Prozess-Zustaende zerstoeren:
   ***************************************************************************/

  delete state_type_start;
  delete state_type_makeconnection1;
  delete state_type_makeconnection2;
  delete state_type_waitforid1;
  delete state_type_waitforid2;
  delete state_type_waitcompletion;
  delete state_type_connected;
  delete state_type_waitdisconnection;
  delete state_type_makeconnection1_dec_1_answ;
  delete state_type_makeconnection1_dec_1_tail;
  delete state_type_makeconnection2_dec_1_answ;
  delete state_type_makeconnection2_dec_1_tail;
  delete state_type_connected_dec_1_answ;
  delete state_type_connected_dec_1_tail;

}

/******************************************************************************
 * Konstruktoren
 *****************************************************************************/

pcs_application_loadgenerator_data::pcs_application_loadgenerator_data(void)
{
}

pcs_application_loadgenerator::pcs_application_loadgenerator(const SCProcessID creator,
                                                             const SCProcessType *proc_type,
                                                             PcsFormalParam_loadgenerator *actual_params) : 
  SCProcess(creator, proc_type, state_type_start, actual_params,
            false)
{
#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Creating " << *this << std::endl;
  }

  /****************************************************************************
   * Initialisierung der formalen Parameter mit den aktuellen Parametern:
   ***************************************************************************/

  v_addr = actual_params->v_addr;

  /****************************************************************************
   * Variableninitialisierung:
   ***************************************************************************/

  v_sp = 0;
  v_dp = 0;
  v_da = 0;
  v_name = 0;
  v_len = 0;
  v_prec = 0;
  v_sec = 0;
  v_descr = 0;
  v_tout = 0;
  v_aaa = 0;
  v_aar = 0;
  v_rcv_wnd = 0;
  v_snd_wnd = 0;
  v_open = 0;
  v_send_to = 0;
  v_urg = false;
  v_counter = 1;

  /****************************************************************************
   * Aktuellen Zustand auf Startzustand setzen:
   ***************************************************************************/

  v_cur_state = state_type_id_start;

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

pcs_application_loadgenerator::pcs_application_loadgenerator(SCMem &save_area) : 
  SCProcess(false, (SCObject *)NULL)
{
  Restore(save_area);

#if _SC_VALIDATION_OPTIMIZE
  /****************************************************************************
   * Ausgangsgroesse des Prozesses initialisieren:
   ***************************************************************************/

  SCSize my_size;

  Size(&my_size);
  SetCurrentSize(my_size.size);
  SetCurrentHistorySize(my_size.historySize);
#endif

  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Recreated " << *this << std::endl;
  }

  /****************************************************************************
   * Auf die Instanz darf nun zugegriffen werden:
   ***************************************************************************/

  GetAutomatonTable()->Insert(Self(), this);
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

pcs_application_loadgenerator_data::~pcs_application_loadgenerator_data(void)
{
}

pcs_application_loadgenerator::~pcs_application_loadgenerator(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Deleting " << *this << std::endl;
  }
}

/******************************************************************************
 * Implementierungsfunktion des SDL-Prozesses
 *****************************************************************************/

void pcs_application_loadgenerator::Body(void)
{
  /****************************************************************************
   * Meldung ausgeben:
   ***************************************************************************/

  if (IsVerbose())
  {
    SCScheduler::outputStream << "Executing " << *this << std::endl;
  }

  /****************************************************************************
   * Hauptschleife:
   ***************************************************************************/

  nextstate:
  v_transition_id = kSCNoTransition;
  backtracking:
  while(true)
  {
    switch(v_cur_state)
    {
      /************************************************************************
       * Starttransition:
       ***********************************************************************/

      case state_type_id_start:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_start, kSCNoAwakeDelay,
                                  &v_signal_read);
        }
        label_jump1:
        switch (v_counter > 2)
        {
          case true:
            break;
          case false:
            v_trace_block.field_received[v_counter] = 0;
            v_counter = v_counter + 1;
            goto label_jump1;
            break;
        }
        v_address[syn_port_1] = v_addr;
        v_address[syn_port_2] = syn_num_of_connections + v_addr;
        SetTimer(Now(), tim_type_send_init);
        v_cur_state = state_type_id_makeconnection1;
        goto nextstate;

      /************************************************************************
       * Zustand 'makeconnection1':
       ***********************************************************************/

      case state_type_id_makeconnection1:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection1,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection1)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection1'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): send_init
            v_cur_state = state_type_id_makeconnection1_dec_1_answ;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection1': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'makeconnection2':
       ***********************************************************************/

      case state_type_id_makeconnection2:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection2,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection2)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection2'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): send_init
            v_cur_state = state_type_id_makeconnection2_dec_1_answ;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection2': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'waitforid1':
       ***********************************************************************/

      case state_type_id_waitforid1:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitforid1, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_waitforid1)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_oid:
              sigparam_oid = (SigParam_oid *)RetrieveInputData();
              assert(sigparam_oid);
              v_name = sigparam_oid->sig_field_1;
              v_sp = sigparam_oid->sig_field_2;
              v_dp = sigparam_oid->sig_field_3;
              v_da = sigparam_oid->sig_field_4;
              delete sigparam_oid;
              break;

            case sig_type_id_of:
              sigparam_of = (SigParam_of *)RetrieveInputData();
              assert(sigparam_of);
              v_name = sigparam_of->sig_field_1;
              delete sigparam_of;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitforid1'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): oid
            v_address[syn_port_1] = v_name;
            SetTimer(Now(), tim_type_send_init);
            v_cur_state = state_type_id_makeconnection2;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): of
            v_trace_block.field_failed_connection = v_trace_block.field_failed_connection + 1;
            SetTimer(Now(), tim_type_send_init);
            v_cur_state = state_type_id_makeconnection1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): send_init
            SetTimer(Now(), tim_type_send_init);
            v_cur_state = state_type_id_waitforid1;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitforid1': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'waitforid2':
       ***********************************************************************/

      case state_type_id_waitforid2:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitforid2, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_waitforid2)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_oid:
              sigparam_oid = (SigParam_oid *)RetrieveInputData();
              assert(sigparam_oid);
              v_name = sigparam_oid->sig_field_1;
              v_sp = sigparam_oid->sig_field_2;
              v_dp = sigparam_oid->sig_field_3;
              v_da = sigparam_oid->sig_field_4;
              delete sigparam_oid;
              break;

            case sig_type_id_of:
              sigparam_of = (SigParam_of *)RetrieveInputData();
              assert(sigparam_of);
              v_name = sigparam_of->sig_field_1;
              delete sigparam_of;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitforid2'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): oid
            v_address[syn_port_2] = v_name;
            SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
            v_cur_state = state_type_id_waitcompletion;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): of
            v_trace_block.field_failed_connection = v_trace_block.field_failed_connection + 1;
            sigparam_close = new SigParam_close;
            assert(sigparam_close);
            sigparam_close->sig_field_1 = v_name;
            Output(blk_tcp::pcs_type_manager, sig_type_close,
                   sigparam_close);
            SetTimer(Now(), tim_type_send_init);
            v_cur_state = state_type_id_makeconnection1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): send_init
            v_cur_state = state_type_id_waitforid2;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitforid2': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'waitcompletion':
       ***********************************************************************/

      case state_type_id_waitcompletion:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitcompletion,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_waitcompletion)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_of:
              sigparam_of = (SigParam_of *)RetrieveInputData();
              assert(sigparam_of);
              v_name = sigparam_of->sig_field_1;
              delete sigparam_of;
              break;

            case sig_type_id_os:
              sigparam_os = (SigParam_os *)RetrieveInputData();
              assert(sigparam_os);
              v_name = sigparam_os->sig_field_1;
              delete sigparam_os;
              break;

            case sig_type_id_oid:
              sigparam_oid = (SigParam_oid *)RetrieveInputData();
              assert(sigparam_oid);
              v_name = sigparam_oid->sig_field_1;
              v_sp = sigparam_oid->sig_field_2;
              v_dp = sigparam_oid->sig_field_3;
              v_da = sigparam_oid->sig_field_4;
              delete sigparam_oid;
              break;

            case sig_type_id_del:
              sigparam_del = (SigParam_del *)RetrieveInputData();
              assert(sigparam_del);
              v_name = sigparam_del->sig_field_1;
              v_len = sigparam_del->sig_field_2;
              v_urg = sigparam_del->sig_field_3;
              delete sigparam_del;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitcompletion'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): of
            v_trace_block.field_failed_connection = v_trace_block.field_failed_connection + 1;
            switch (v_name == v_address[syn_port_1])
            {
              case true:
                sigparam_close = new SigParam_close;
                assert(sigparam_close);
                sigparam_close->sig_field_1 = v_address[syn_port_2];
                Output(blk_tcp::pcs_type_manager, sig_type_close,
                       sigparam_close);
                break;
              case false:
                sigparam_close = new SigParam_close;
                assert(sigparam_close);
                sigparam_close->sig_field_1 = v_address[syn_port_1];
                Output(blk_tcp::pcs_type_manager, sig_type_close,
                       sigparam_close);
                break;
            }
            SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
            v_cur_state = state_type_id_makeconnection1;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): send_init
            SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
            v_cur_state = state_type_id_waitcompletion;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): os
            v_trace_block.field_succeeded_connection = v_trace_block.field_succeeded_connection + 1;
            switch (v_open == 0)
            {
              case true:
                v_open = v_open + 1;
                v_cur_state = state_type_id_waitcompletion;
                goto nextstate;
                break;
              case false:
                SetTimer(Now() + syn_connection_time, tim_type_send_fin);
                v_send_to = 1;
                v_open = 0;
                SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
                v_cur_state = state_type_id_connected;
                goto nextstate;
                break;
            }
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): oid
            v_cur_state = state_type_id_waitcompletion;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): del
            v_trace_block.field_received[(v_name % 2) + 1] = v_trace_block.field_received[(v_name % 2) + 1] + v_len;
            v_cur_state = state_type_id_waitcompletion;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitcompletion': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'connected':
       ***********************************************************************/

      case state_type_id_connected:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_connected, kSCNoAwakeDelay,
                                  &v_signal_read);
          if (v_cur_state != state_type_id_connected)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_del:
              sigparam_del = (SigParam_del *)RetrieveInputData();
              assert(sigparam_del);
              v_name = sigparam_del->sig_field_1;
              v_len = sigparam_del->sig_field_2;
              v_urg = sigparam_del->sig_field_3;
              delete sigparam_del;
              break;

            case sig_type_id_closing:
              sigparam_closing = (SigParam_closing *)RetrieveInputData();
              assert(sigparam_closing);
              v_name = sigparam_closing->sig_field_1;
              delete sigparam_closing;
              break;

            case sig_type_id_err:
              sigparam_err = (SigParam_err *)RetrieveInputData();
              assert(sigparam_err);
              v_name = sigparam_err->sig_field_1;
              v_descr = sigparam_err->sig_field_2;
              delete sigparam_err;
              break;

            case sig_type_id_stresp:
              sigparam_stresp = (SigParam_stresp *)RetrieveInputData();
              assert(sigparam_stresp);
              v_name = sigparam_stresp->sig_field_1;
              v_dp = sigparam_stresp->sig_field_2;
              v_da = sigparam_stresp->sig_field_3;
              v_rcv_wnd = sigparam_stresp->sig_field_4;
              v_snd_wnd = sigparam_stresp->sig_field_5;
              v_aaa = sigparam_stresp->sig_field_6;
              v_aar = sigparam_stresp->sig_field_7;
              v_urg = sigparam_stresp->sig_field_8;
              v_prec = sigparam_stresp->sig_field_9;
              v_sec = sigparam_stresp->sig_field_10;
              v_tout = sigparam_stresp->sig_field_11;
              delete sigparam_stresp;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'connected'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): del
            v_trace_block.field_received[(v_name % 2) + 1] = v_trace_block.field_received[(v_name % 2) + 1] + v_len;
            sigparam_allocate = new SigParam_allocate;
            assert(sigparam_allocate);
            sigparam_allocate->sig_field_1 = v_name;
            sigparam_allocate->sig_field_2 = v_len;
            Output(blk_tcp::pcs_type_manager, sig_type_allocate,
                   sigparam_allocate);
            v_cur_state = state_type_id_connected;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): send_init
            v_cur_state = state_type_id_connected_dec_1_answ;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): send_fin
            sigparam_status = new SigParam_status;
            assert(sigparam_status);
            sigparam_status->sig_field_1 = v_address[syn_port_1];
            Output(blk_tcp::pcs_type_manager, sig_type_status,
                   sigparam_status);
            sigparam_close = new SigParam_close;
            assert(sigparam_close);
            sigparam_close->sig_field_1 = v_address[syn_port_1];
            Output(blk_tcp::pcs_type_manager, sig_type_close,
                   sigparam_close);
            v_cur_state = state_type_id_connected;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): closing
            sigparam_close = new SigParam_close;
            assert(sigparam_close);
            sigparam_close->sig_field_1 = v_address[syn_port_2];
            Output(blk_tcp::pcs_type_manager, sig_type_close,
                   sigparam_close);
            v_cur_state = state_type_id_waitdisconnection;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 4: // Input signal(s): err
            switch (Decision(2, v_descr == syn_fatal_error, v_descr == syn_default_error))
            {
              case kSCDecisionBase + 0:
                sigparam_abort = new SigParam_abort;
                assert(sigparam_abort);
                sigparam_abort->sig_field_1 = v_address[((v_name + 1) % 2) + 1];
                Output(blk_tcp::pcs_type_manager, sig_type_abort,
                       sigparam_abort);
                v_cur_state = state_type_id_waitdisconnection;
                goto nextstate;
                break;
              case kSCDecisionBase + 1:
                break;
              default:
                std::cerr << "Not specified decision value!" <<
                             std::endl;
                break;
            }
            v_cur_state = state_type_id_connected;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 5: // Input signal(s): stresp
            v_cur_state = state_type_id_connected;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'connected': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'waitdisconnection':
       ***********************************************************************/

      case state_type_id_waitdisconnection:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_waitdisconnection,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_waitdisconnection)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Signalparamter des konsumierten Signals lesen:
         *********************************************************************/

        if (v_signal_read)
        {
          switch(v_signal_read->GetID())
          {
            case sig_type_id_del:
              sigparam_del = (SigParam_del *)RetrieveInputData();
              assert(sigparam_del);
              v_name = sigparam_del->sig_field_1;
              v_len = sigparam_del->sig_field_2;
              v_urg = sigparam_del->sig_field_3;
              delete sigparam_del;
              break;

            case sig_type_id_err:
              sigparam_err = (SigParam_err *)RetrieveInputData();
              assert(sigparam_err);
              v_name = sigparam_err->sig_field_1;
              v_descr = sigparam_err->sig_field_2;
              delete sigparam_err;
              break;

            case sig_type_id_ter:
              sigparam_ter = (SigParam_ter *)RetrieveInputData();
              assert(sigparam_ter);
              v_name = sigparam_ter->sig_field_1;
              v_descr = sigparam_ter->sig_field_2;
              delete sigparam_ter;
              break;

          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'waitdisconnection'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input signal(s): del
            v_trace_block.field_received[(v_name % 2) + 1] = v_trace_block.field_received[(v_name % 2) + 1] + v_len;
            sigparam_allocate = new SigParam_allocate;
            assert(sigparam_allocate);
            sigparam_allocate->sig_field_1 = v_address[(v_name % 2) + 1];
            sigparam_allocate->sig_field_2 = v_len;
            Output(blk_tcp::pcs_type_manager, sig_type_allocate,
                   sigparam_allocate);
            v_cur_state = state_type_id_waitdisconnection;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input signal(s): err
            v_cur_state = state_type_id_waitdisconnection;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input signal(s): send_init
            v_cur_state = state_type_id_waitdisconnection;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 3: // Input signal(s): ter
            v_trace_block.field_succeeded_connection = v_trace_block.field_succeeded_connection + 1;
            v_open = v_open + 1;
            switch (v_open == 2)
            {
              case true:
                v_open = 0;
                SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
                v_cur_state = state_type_id_makeconnection1;
                goto nextstate;
                break;
              case false:
                v_cur_state = state_type_id_waitdisconnection;
                goto nextstate;
                break;
            }
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'waitdisconnection': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'makeconnection1_dec_1_answ':
       ***********************************************************************/

      case state_type_id_makeconnection1_dec_1_answ:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection1_dec_1_answ,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection1_dec_1_answ)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection1_dec_1_answ'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            sigparam_upo = new SigParam_upo;
            assert(sigparam_upo);
            sigparam_upo->sig_field_1 = v_address[syn_port_1];
            sigparam_upo->sig_field_2 = syn_standard_timeout;
            sigparam_upo->sig_field_3 = syn_standard_timeout_action;
            sigparam_upo->sig_field_4 = syn_standard_prec;
            sigparam_upo->sig_field_5 = syn_standard_security;
            Output(blk_tcp::pcs_type_manager, sig_type_upo, sigparam_upo);
            v_cur_state = state_type_id_makeconnection1_dec_1_tail;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input None
            sigparam_fspo = new SigParam_fspo;
            assert(sigparam_fspo);
            sigparam_fspo->sig_field_1 = v_address[syn_port_1];
            sigparam_fspo->sig_field_2 = v_address[syn_port_2];
            sigparam_fspo->sig_field_3 = syn_server_a_address;
            sigparam_fspo->sig_field_4 = syn_standard_timeout;
            sigparam_fspo->sig_field_5 = syn_standard_timeout_action;
            sigparam_fspo->sig_field_6 = syn_standard_prec;
            sigparam_fspo->sig_field_7 = syn_standard_security;
            Output(blk_tcp::pcs_type_manager, sig_type_fspo,
                   sigparam_fspo);
            v_cur_state = state_type_id_makeconnection1_dec_1_tail;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 2: // Input None
            sigparam_ao = new SigParam_ao;
            assert(sigparam_ao);
            sigparam_ao->sig_field_1 = v_address[syn_port_2];
            sigparam_ao->sig_field_2 = v_address[syn_port_1];
            sigparam_ao->sig_field_3 = syn_server_a_address;
            sigparam_ao->sig_field_4 = syn_standard_timeout;
            sigparam_ao->sig_field_5 = syn_standard_timeout_action;
            sigparam_ao->sig_field_6 = syn_standard_prec;
            sigparam_ao->sig_field_7 = syn_standard_security;
            Output(blk_tcp::pcs_type_manager, sig_type_ao, sigparam_ao);
            v_cur_state = state_type_id_makeconnection1_dec_1_tail;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection1_dec_1_answ': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'makeconnection1_dec_1_tail':
       ***********************************************************************/

      case state_type_id_makeconnection1_dec_1_tail:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection1_dec_1_tail,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection1_dec_1_tail)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection1_dec_1_tail'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            v_cur_state = state_type_id_waitforid1;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection1_dec_1_tail': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'makeconnection2_dec_1_answ':
       ***********************************************************************/

      case state_type_id_makeconnection2_dec_1_answ:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection2_dec_1_answ,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection2_dec_1_answ)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection2_dec_1_answ'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            sigparam_ao = new SigParam_ao;
            assert(sigparam_ao);
            sigparam_ao->sig_field_1 = v_address[syn_port_2];
            sigparam_ao->sig_field_2 = v_address[syn_port_1];
            sigparam_ao->sig_field_3 = syn_server_a_address;
            sigparam_ao->sig_field_4 = syn_standard_timeout;
            sigparam_ao->sig_field_5 = syn_standard_timeout_action;
            sigparam_ao->sig_field_6 = syn_standard_prec;
            sigparam_ao->sig_field_7 = syn_standard_security;
            Output(blk_tcp::pcs_type_manager, sig_type_ao, sigparam_ao);
            v_cur_state = state_type_id_makeconnection2_dec_1_tail;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input None
            sigparam_aod = new SigParam_aod;
            assert(sigparam_aod);
            sigparam_aod->sig_field_1 = v_address[syn_port_2];
            sigparam_aod->sig_field_2 = v_address[syn_port_1];
            sigparam_aod->sig_field_3 = syn_server_a_address;
            sigparam_aod->sig_field_4 = syn_standard_timeout;
            sigparam_aod->sig_field_5 = syn_standard_timeout_action;
            sigparam_aod->sig_field_6 = syn_standard_prec;
            sigparam_aod->sig_field_7 = syn_standard_security;
            sigparam_aod->sig_field_8 = syn_data;
            sigparam_aod->sig_field_9 = syn_no_push_flag;
            sigparam_aod->sig_field_10 = syn_no_urgent_flag;
            Output(blk_tcp::pcs_type_manager, sig_type_aod, sigparam_aod);
            v_cur_state = state_type_id_makeconnection2_dec_1_tail;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection2_dec_1_answ': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'makeconnection2_dec_1_tail':
       ***********************************************************************/

      case state_type_id_makeconnection2_dec_1_tail:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_makeconnection2_dec_1_tail,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_makeconnection2_dec_1_tail)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'makeconnection2_dec_1_tail'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            v_cur_state = state_type_id_waitforid2;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'makeconnection2_dec_1_tail': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'connected_dec_1_answ':
       ***********************************************************************/

      case state_type_id_connected_dec_1_answ:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_connected_dec_1_answ,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_connected_dec_1_answ)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'connected_dec_1_answ'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            v_send_to = v_address[syn_port_2];
            v_cur_state = state_type_id_connected_dec_1_tail;
            goto nextstate;
            break;

          case kSCTransitionIDBase + 1: // Input None
            v_send_to = v_address[syn_port_1];
            v_cur_state = state_type_id_connected_dec_1_tail;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'connected_dec_1_answ': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      /************************************************************************
       * Zustand 'connected_dec_1_tail':
       ***********************************************************************/

      case state_type_id_connected_dec_1_tail:
        if (v_transition_id == kSCNoTransition)
        {
          v_transition_id = State(state_type_connected_dec_1_tail,
                                  kSCNoAwakeDelay, &v_signal_read);
          if (v_cur_state != state_type_id_connected_dec_1_tail)
          {
            goto backtracking;
          }
        }

        /**********************************************************************
         * Transitionen des Zustands 'connected_dec_1_tail'
         *********************************************************************/

        switch(v_transition_id)
        {
          case kSCTransitionIDBase + 0: // Input None
            sigparam_send = new SigParam_send;
            assert(sigparam_send);
            sigparam_send->sig_field_1 = v_send_to;
            sigparam_send->sig_field_2 = syn_data;
            sigparam_send->sig_field_3 = syn_no_push_flag;
            sigparam_send->sig_field_4 = syn_no_urgent_flag;
            sigparam_send->sig_field_5 = syn_standard_timeout;
            sigparam_send->sig_field_6 = syn_standard_timeout_action;
            Output(blk_tcp::pcs_type_manager, sig_type_send,
                   sigparam_send);
            SetTimer(Now() + syn_load_generation_delay, tim_type_send_init);
            v_cur_state = state_type_id_connected;
            goto nextstate;
            break;

          case kSCNoTransition:
            break;
          default:
            std::cerr << "State 'connected_dec_1_tail': Invalid transition." <<
                         std::endl;
            break;
        }
        break;

      default:
        std::cerr << "Process 'loadgenerator': Invalid process state." <<
                     std::endl;
        break;
    }
  }
}

/******************************************************************************
 * Save-Methode zur Speicherung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_application_loadgenerator::Save(SCMem &save_area) const
{
  /****************************************************************************
   * Speicherung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Save(save_area);

  /****************************************************************************
   * Sicherung der Variablen:
   ***************************************************************************/

  save_area.Store(&v_sp, sizeof(SCInteger));
  save_area.Store(&v_dp, sizeof(SCInteger));
  save_area.Store(&v_da, sizeof(SCInteger));
  save_area.Store(&v_name, sizeof(SCInteger));
  save_area.Store(&v_len, sizeof(SCInteger));
  save_area.Store(&v_prec, sizeof(SCInteger));
  save_area.Store(&v_sec, sizeof(SCInteger));
  save_area.Store(&v_descr, sizeof(SCInteger));
  save_area.Store(&v_tout, sizeof(SCInteger));
  save_area.Store(&v_aaa, sizeof(SCInteger));
  save_area.Store(&v_aar, sizeof(SCInteger));
  save_area.Store(&v_rcv_wnd, sizeof(SCInteger));
  save_area.Store(&v_snd_wnd, sizeof(SCInteger));
  save_area.Store(&v_open, sizeof(SCInteger));
  save_area.Store(&v_send_to, sizeof(SCInteger));
  save_area.Store(&v_urg, sizeof(SCBoolean));
  v_trace_block.Save(save_area);
  v_address.Save(save_area);
  save_area.Store(&v_counter, sizeof(SCInteger));

  /****************************************************************************
   * Sicherung der formalen Parameter
   ***************************************************************************/

  save_area.Store(&v_addr, sizeof(SCInteger));

  /****************************************************************************
   * Speicherung der Zustandsvariablen
   ***************************************************************************/

  save_area.Store(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung des Prozesszustands
 *****************************************************************************/

SCBoolean pcs_application_loadgenerator::Restore(SCMem &save_area)
{
  /****************************************************************************
   * Restaurierung der Daten der Basisklasse
   ***************************************************************************/

  SCProcess::Restore(save_area);

  /****************************************************************************
   * Restaurierung der Variablen:
   ***************************************************************************/

  save_area.Restore(&v_sp, sizeof(SCInteger));
  save_area.Restore(&v_dp, sizeof(SCInteger));
  save_area.Restore(&v_da, sizeof(SCInteger));
  save_area.Restore(&v_name, sizeof(SCInteger));
  save_area.Restore(&v_len, sizeof(SCInteger));
  save_area.Restore(&v_prec, sizeof(SCInteger));
  save_area.Restore(&v_sec, sizeof(SCInteger));
  save_area.Restore(&v_descr, sizeof(SCInteger));
  save_area.Restore(&v_tout, sizeof(SCInteger));
  save_area.Restore(&v_aaa, sizeof(SCInteger));
  save_area.Restore(&v_aar, sizeof(SCInteger));
  save_area.Restore(&v_rcv_wnd, sizeof(SCInteger));
  save_area.Restore(&v_snd_wnd, sizeof(SCInteger));
  save_area.Restore(&v_open, sizeof(SCInteger));
  save_area.Restore(&v_send_to, sizeof(SCInteger));
  save_area.Restore(&v_urg, sizeof(SCBoolean));
  v_trace_block.Restore(save_area);
  v_address.Restore(save_area);
  save_area.Restore(&v_counter, sizeof(SCInteger));

  /****************************************************************************
   * Restaurierung der formalen Parameter
   ***************************************************************************/

  save_area.Restore(&v_addr, sizeof(SCInteger));

  /****************************************************************************
   * Restaurierung der Zustandsvariablen
   ***************************************************************************/

  save_area.Restore(&v_cur_state, sizeof(v_cur_state));

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz
 *****************************************************************************/

void pcs_application_loadgenerator::Size(SCSize *cur_size) const
{
  /****************************************************************************
   * Berechnung der Groesse der Basisklasse
   ***************************************************************************/

  SCProcess::Size(cur_size);

  /****************************************************************************
   * Berechnung der Variablengroessen:
   ***************************************************************************/

  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCInteger);
  cur_size->size += sizeof(SCBoolean);
  v_trace_block.Size(cur_size);
  v_address.Size(cur_size);
  cur_size->size += sizeof(SCInteger);

  /****************************************************************************
   * Berechnung der Groessen der formalen Parameter
   ***************************************************************************/

  cur_size->size += sizeof(SCInteger);

  /****************************************************************************
   * Groesse der Zustandsvariablen
   ***************************************************************************/

  cur_size->size += sizeof(v_cur_state);

}

/******************************************************************************
 * Display-Methode
 *****************************************************************************/

SCStream& operator<<(SCStream &out, const pcs_application_loadgenerator &me)
{
  return me.Display(out);
}
