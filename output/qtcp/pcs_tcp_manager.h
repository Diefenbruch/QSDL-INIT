/******************************************************************************
 *                            pcs_tcp_manager.h
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

#ifndef _PCS_TCP_MANAGER_H_
#define _PCS_TCP_MANAGER_H_

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "blk_tcp.h"

#include <SCL/SCProcess.h>
#include <SCL/SCStateType.h>
#include <SCL/SCTimerType.h>
#include <SCL/SCProcedureType.h>

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'manager' (Data)
 *****************************************************************************/

class pcs_tcp_manager_data : public blk_tcp
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktor
     *************************************************************************/

    pcs_tcp_manager_data(void);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_tcp_manager_data(void);

    /**************************************************************************
     * Prozedurtypen (statisch)
     *************************************************************************/


    /**************************************************************************
     * Benutzerdefinierte SDL-Datentypen auf Prozessebene
     *************************************************************************/

    /**************************************************************************
     * SDL-Newtype: Array 'portaddress':
     *************************************************************************/

    struct DataType_portaddress : public SCArray<SCPid>
    {
      // Konstruktor:
      DataType_portaddress(void) : SCArray<SCPid> (0, 256, (SCPid)0L) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
    };
    /**************************************************************************
     * SDL-Newtype: Array 'applicationaddress':
     *************************************************************************/

    struct DataType_applicationaddress : public SCArray<SCPid>
    {
      // Konstruktor:
      DataType_applicationaddress(void) : SCArray<SCPid> (0,
                                                          256,
                                                          (SCPid)0L) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCPid));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCPid));
      }
    };
    /**************************************************************************
     * SDL-Newtype: Array 'existport':
     *************************************************************************/

    struct DataType_existport : public SCArray<SCBoolean>
    {
      // Konstruktor:
      DataType_existport(void) : SCArray<SCBoolean> (0, 256,
                                                     (SCBoolean)false) {};
      // Virtuelle Save-Methode:
      SCBoolean Save(SCMem &save_area) const
      {
        save_area.Store(array, (highBound - lowBound + 1) * sizeof(SCBoolean));

        return true;
      }
      // Virtuelle HistorySave-Methode (fuer History-Variablen):
      SCBoolean HistorySave(SCMem &save_area) const
      {
        save_area.HistoryStore(array, (highBound - lowBound + 1) * sizeof(SCBoolean));

        return true;
      }
      // Virtuelle Restore-Methode:
      SCBoolean Restore(SCMem &save_area)
      {
        save_area.Restore(array, (highBound - lowBound + 1) * sizeof(SCBoolean));

        return true;
      }
      // Virtuelle HistoryRestore-Methode (fuer History-Variablen):
      SCBoolean HistoryRestore(SCMem &save_area)
      {
        save_area.HistoryRestore(array, (highBound - lowBound + 1) * sizeof(SCBoolean));

        return true;
      }
      // Virtuelle Size-Methode:
      void Size(SCSize *cur_size) const
      {
        cur_size->size += ((highBound - lowBound + 1) * sizeof(SCBoolean));
      }
      // Virtuelle HistorySize-Methode (fuer History-Variablen):
      void HistorySize(SCSize *cur_size) const
      {
        cur_size->historySize += ((highBound - lowBound + 1) * sizeof(SCBoolean));
      }
    };
    static SCInteger syn_error_no_free_port;
    static SCInteger syn_undefined_destinationport;
    static SCInteger syn_undefined_destinationaddress;

    /**************************************************************************
     * IDs der Prozedurtypen
     *************************************************************************/

    enum
    {
      pcd_type_id_createport = kSCProcedureTypeIDBase + 0,
      pcd_type_id_getfreeport
    };

    /**************************************************************************
     * Strukturen fuer die formalen Parameter der Prozeduren
     *************************************************************************/


    /**************************************************************************
     * Variablen fuer die formalen Parameter der Prozeduren
     *************************************************************************/


};

/******************************************************************************
 * Prozessklasse des SDL-Prozesses 'manager' (Instanz)
 *****************************************************************************/

class pcs_tcp_manager : public SCProcess, public pcs_tcp_manager_data
{
  public:
    /**************************************************************************
     * Initialisierungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static SCBoolean Initialize(void);

    /**************************************************************************
     * Beendigungsfunktion des Prozesses (statisch)
     *************************************************************************/

    static void Finish(void);

    /**************************************************************************
     * Konstruktoren
     *************************************************************************/

    pcs_tcp_manager(const SCProcessID, const SCProcessType *);
    pcs_tcp_manager(SCMem &);

    /**************************************************************************
     * Destruktor
     *************************************************************************/

    ~pcs_tcp_manager(void);

    /**************************************************************************
     * Prototypen fuer die Prozeduren
     *************************************************************************/

    void createport(DataType_portrange, SCBoolean &);
    void getfreeport(DataType_portrange &);

    /**************************************************************************
     * Virtuelle Save- & Restore-Methoden
     *************************************************************************/

    SCBoolean Save(SCMem &) const;
    SCBoolean Restore(SCMem &);

    /**************************************************************************
     * Virtuelle Size-Methode
     *************************************************************************/

    void Size(SCSize *) const;

    /**************************************************************************
     * Display-Methoden
     *************************************************************************/

    friend SCStream& operator<<(SCStream &, const pcs_tcp_manager &);

    /**************************************************************************
     * Implementierungsmethode
     *************************************************************************/

    void Body(void);

    /**************************************************************************
     * Lokale Variablen des Prozesses
     *************************************************************************/

    SCInteger v_sp;
    SCInteger v_dp;
    SCInteger v_da;
    SCInteger v_tout;
    SCInteger v_toa;
    SCInteger v_prec;
    SCInteger v_sec;
    SCInteger v_len;
    SCInteger v_rcv_wnd;
    SCInteger v_snd_wnd;
    SCInteger v_name;
    SCInteger v_descr;
    SCInteger v_aaa;
    SCInteger v_aar;
    SCInteger v_run;
    SCBoolean v_urg;
    SCBoolean v_psh;
    SCBoolean v_ok;
    DataType_portrange v_n;
    DataType_existport v_exist;
    DataType_portaddress v_port_addr;
    DataType_applicationaddress v_appl_addr;
    DataType_tcp v_tcp_in;

    /**************************************************************************
     * IDs der Zustandstypen des Prozesses
     *************************************************************************/

    enum
    {
      state_type_id_start = kSCStateTypeIDBase + 16,
      state_type_id_waitforinput
    };

    /**************************************************************************
     * Zustandstypen des Prozesses (statisch)
     *************************************************************************/

    static SCStateType * state_type_start;
    static SCStateType * state_type_waitforinput;

    /**************************************************************************
     * Input-Sets der Transitionen des Prozesses (statisch)
     *************************************************************************/

    static SCSignalID input_set_waitforinput_transition0[];
    static SCSignalID input_set_waitforinput_transition1[];
    static SCSignalID input_set_waitforinput_transition2[];
    static SCSignalID input_set_waitforinput_transition3[];
    static SCSignalID input_set_waitforinput_transition4[];
    static SCSignalID input_set_waitforinput_transition5[];
    static SCSignalID input_set_waitforinput_transition6[];
    static SCSignalID input_set_waitforinput_transition7[];
    static SCSignalID input_set_waitforinput_transition8[];
    static SCSignalID input_set_waitforinput_transition9[];
    static SCSignalID input_set_waitforinput_transition10[];
    static SCSignalID input_set_waitforinput_transition11[];
    static SCSignalID input_set_waitforinput_transition12[];
    static SCSignalID input_set_waitforinput_transition13[];
    static SCSignalID input_set_waitforinput_transition14[];
    static SCSignalID input_set_waitforinput_transition15[];
    static SCSignalID input_set_waitforinput_transition16[];
    static SCSignalID input_set_waitforinput_transition17[];

    /**************************************************************************
     * Standardvariablen zur Prozesssteuerung
     *************************************************************************/

    SCInteger v_cur_state;
    SCInteger v_transition_id;
    SCTransition *v_transition;
    SCSignalType *v_signal_read;

    /**************************************************************************
     * Friend-Deklarationen fuer Prozeduren
     *************************************************************************/

};

#endif
