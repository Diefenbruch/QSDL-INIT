/******************************************************************************
 *                            sys_qtcp.cpp
 *
 * Generated by QCG in January, 28, 2019 at 13:54:45
 *           on system: raspberrypi (Linux 4.14.79-v7+ armv7l)
 *
 * User: QSDL
 *
 * Copyright (C) 1995-98 Marc Diefenbruch (md@informatik.uni-essen.de)
 *                and Joerg Ruehl (jruehl@informatik.uni-essen.de)
 *
 * All rights reserved.
 *
 *****************************************************************************/

/******************************************************************************
 * Includes
 *****************************************************************************/

#include "sys_qtcp.h"
#include "blk_application.h"
#include "blk_tcp.h"
#include "blk_ip.h"
#include "blk_medium.h"

#include <fstream> // for MSC tracing

#include <SCL/SCScheduler.h>
#include <SCL/SCSocket.h>
#include <SCL/SCTraceControl.h>
#include <SCL/SCTimerControl.h>
#include <SCL/SCTraceEventMSC.h>
#include <SCL/SCTraceSocket.h>
#include <PEV/PEEventDispatcher.h>

/******************************************************************************
 * Signaltypen der SDL-Signale auf Systemebene (statisch)
 *****************************************************************************/

sys_qtcp::SigType_status * sys_qtcp::sig_type_status = NULL;
sys_qtcp::SigType_close * sys_qtcp::sig_type_close = NULL;
sys_qtcp::SigType_abort * sys_qtcp::sig_type_abort = NULL;
sys_qtcp::SigType_os * sys_qtcp::sig_type_os = NULL;
sys_qtcp::SigType_of * sys_qtcp::sig_type_of = NULL;
sys_qtcp::SigType_process_terminated * sys_qtcp::sig_type_process_terminated = NULL;
sys_qtcp::SigType_closing * sys_qtcp::sig_type_closing = NULL;
sys_qtcp::SigType_upo * sys_qtcp::sig_type_upo = NULL;
sys_qtcp::SigType_fspo * sys_qtcp::sig_type_fspo = NULL;
sys_qtcp::SigType_ao * sys_qtcp::sig_type_ao = NULL;
sys_qtcp::SigType_aod * sys_qtcp::sig_type_aod = NULL;
sys_qtcp::SigType_send * sys_qtcp::sig_type_send = NULL;
sys_qtcp::SigType_allocate * sys_qtcp::sig_type_allocate = NULL;
sys_qtcp::SigType_oid * sys_qtcp::sig_type_oid = NULL;
sys_qtcp::SigType_del * sys_qtcp::sig_type_del = NULL;
sys_qtcp::SigType_ter * sys_qtcp::sig_type_ter = NULL;
sys_qtcp::SigType_err * sys_qtcp::sig_type_err = NULL;
sys_qtcp::SigType_stresp * sys_qtcp::sig_type_stresp = NULL;
sys_qtcp::SigType_tcp_packet * sys_qtcp::sig_type_tcp_packet = NULL;
sys_qtcp::SigType_ip_packet * sys_qtcp::sig_type_ip_packet = NULL;

/******************************************************************************
 * Konstanten (Synonyme) auf Systemebene (statisch)
 *****************************************************************************/

SCInteger sys_qtcp::syn_medium_buffer;
SCDuration sys_qtcp::syn_medium_delay;
SCDuration sys_qtcp::syn_mrtt;
SCDuration sys_qtcp::syn_default_to;
SCDuration sys_qtcp::syn_time_out;
SCInteger sys_qtcp::syn_maxnr;
SCInteger sys_qtcp::syn_window_size;
SCInteger sys_qtcp::syn_buffer_size;
SCInteger sys_qtcp::syn_max_retransmit;
SCDuration sys_qtcp::syn_connection_time;
SCDuration sys_qtcp::syn_wait_delay;
SCInteger sys_qtcp::syn_destroy_rate;
SCBoolean sys_qtcp::syn_fault;
SCInteger sys_qtcp::syn_standard;
SCInteger sys_qtcp::syn_max_connections;
SCInteger sys_qtcp::syn_num_of_connections;
SCInteger sys_qtcp::syn_server_a_address;
SCInteger sys_qtcp::syn_server_b_address;
SCInteger sys_qtcp::syn_standard_timeout;
SCInteger sys_qtcp::syn_standard_timeout_action;
SCInteger sys_qtcp::syn_standard_prec;
SCInteger sys_qtcp::syn_standard_security;
SCBoolean sys_qtcp::syn_no_ack_flag;
SCBoolean sys_qtcp::syn_no_push_flag;
SCBoolean sys_qtcp::syn_no_urgent_flag;
SCBoolean sys_qtcp::syn_no_fin_flag;
SCBoolean sys_qtcp::syn_no_syn_flag;
SCBoolean sys_qtcp::syn_no_reset_flag;
SCBoolean sys_qtcp::syn_ack_flag;
SCBoolean sys_qtcp::syn_push_flag;
SCBoolean sys_qtcp::syn_fin_flag;
SCBoolean sys_qtcp::syn_syn_flag;
SCBoolean sys_qtcp::syn_reset_flag;
SCInteger sys_qtcp::syn_fatal_error;
SCInteger sys_qtcp::syn_default_error;
SCDuration sys_qtcp::syn_load_generation_delay;

/******************************************************************************
 * Initialisierungsfunktion der SDL-Systemklasse (statisch)
 *****************************************************************************/

SCBoolean sys_qtcp::Initialize(SCIndet *run_type, SCSocket *sensor_socket,
                               SCBoolean fairness, SCBoolean verbose,
                               SCBoolean msc_tracing, SCBoolean socket_tracing,
                               SCBoolean pev_tracing, const char *file_name,
                               const char *host_name, const SCNatural port_number,
                               const char *config_file_name,
                               SCReal display_rate)
{
  SCBoolean result = true;
  SCTrace *tracing;

  if (verbose) std::cout << "Initializing system qtcp..." << std::endl;

  /****************************************************************************
   * Datentpyen auf Systemebene initialisieren:
   ***************************************************************************/

  syn_medium_buffer = 5000;
  syn_medium_delay = 0;
  syn_mrtt = (syn_medium_delay * 3) + 3;
  syn_default_to = (syn_medium_delay * 3) + 2;
  syn_time_out = (syn_medium_delay * 3) + 3;
  syn_maxnr = 28000;
  syn_window_size = syn_maxnr / 2;
  syn_buffer_size = 256;
  syn_max_retransmit = 3;
  syn_connection_time = getenv("QPAR_CONNECTION_TIME") != NULL ?
  (std::cout << "External Synonym 'connection_time' evaluates to " <<
                atof(getenv("QPAR_CONNECTION_TIME")) << std::endl,
                atof(getenv("QPAR_CONNECTION_TIME"))) : 
  (std::cerr << "Environment Variable QPAR_CONNECTION_TIME for external Synonym 'connection_time' not set!\n",
                0.0);
  if (getenv("QPAR_CONNECTION_TIME") == NULL)
    result = false;
  syn_wait_delay = (syn_medium_delay / 2) + 1;
  syn_destroy_rate = 20;
  syn_fault = false;
  syn_standard = 516;
  syn_max_connections = 256;
  syn_num_of_connections = getenv("QPAR_NUM_OF_CONNECTIONS") != NULL ?
  (std::cout << "External Synonym 'num_of_connections' evaluates to " <<
                atoi(getenv("QPAR_NUM_OF_CONNECTIONS")) << std::endl,
                atoi(getenv("QPAR_NUM_OF_CONNECTIONS"))) : 
  (std::cerr << "Environment Variable QPAR_NUM_OF_CONNECTIONS for external Synonym 'num_of_connections' not set!\n",
                0);
  if (getenv("QPAR_NUM_OF_CONNECTIONS") == NULL)
    result = false;
  syn_server_a_address = 111;
  syn_server_b_address = 112;
  syn_standard_timeout = 10;
  syn_standard_timeout_action = 1;
  syn_standard_prec = 0;
  syn_standard_security = 0;
  syn_no_ack_flag = false;
  syn_no_push_flag = false;
  syn_no_urgent_flag = false;
  syn_no_fin_flag = false;
  syn_no_syn_flag = false;
  syn_no_reset_flag = false;
  syn_ack_flag = true;
  syn_push_flag = true;
  syn_fin_flag = true;
  syn_syn_flag = true;
  syn_reset_flag = true;
  syn_fatal_error = 10;
  syn_default_error = 1;
  syn_load_generation_delay = 0.1;

  if (!result)
  {
    std::cerr << std::endl << "System initialization failed!" <<
                 std::endl;
    return false;
  }

  /****************************************************************************
   * Tracing initialisieren:
   ***************************************************************************/

  SCTraceControl::Initialize();

  if (msc_tracing)
  {
    /**************************************************************************
     * MSC-Tracingobjekt erzeugen:
     *************************************************************************/

    SCStream *out = new SCStream(file_name);
    tracing = new SCTraceEventMSC(out, scfTraceAll, true, "qtcp");
    assert(tracing);
    SCTraceControl::AddTrace(tracing);
  }

  if (socket_tracing)
  {
    /**************************************************************************
     * Socket-Tracingobjekt erzeugen:
     *************************************************************************/

    tracing = new SCTraceSocket(scfTraceAll, host_name, port_number);
    assert(tracing);
    if (!((SCTraceSocket *)tracing)->IsOpen())
    {
      delete tracing;
    }
    else
    {
      SCTraceControl::AddTrace(tracing);
    }
  }

  if (pev_tracing)
  {
    /**************************************************************************
     * Performance-Evaluation-Tracingobjekt erzeugen:
     *************************************************************************/

    tracing = new PEEventDispatcher(config_file_name, "qtcp",
                                    display_rate);
    assert(tracing);
    SCTraceControl::AddTrace(tracing);
  }

  /****************************************************************************
   * Scheduler initialisieren:
   ***************************************************************************/

  if (verbose) std::cout << "Initializing scheduler..." << std::endl;
  result = SCScheduler::Initialize(run_type, sensor_socket, fairness,
                                   verbose, kSCDefaultTableSize,
                                   1.0 / display_rate);
  if (!result)
  {
    std::cerr << std::endl << "System initialization failed!" <<
                 std::endl;
    return false;
  }

  /****************************************************************************
   * Timer-Prozess erzeugen und schedulen:
   ***************************************************************************/

  SCScheduler::Schedule(new SCTimerControl);

  /****************************************************************************
   * Signaltypen der SDL-Signale auf Systemebene initialisieren:
   ***************************************************************************/

  sig_type_status = new SigType_status(sig_type_id_status, "status");
  sig_type_close = new SigType_close(sig_type_id_close, "close");
  sig_type_abort = new SigType_abort(sig_type_id_abort, "abort");
  sig_type_os = new SigType_os(sig_type_id_os, "os");
  sig_type_of = new SigType_of(sig_type_id_of, "of");
  sig_type_process_terminated = new SigType_process_terminated(sig_type_id_process_terminated,
                                                               "process_terminated");
  sig_type_closing = new SigType_closing(sig_type_id_closing,
                                         "closing");
  sig_type_upo = new SigType_upo(sig_type_id_upo, "upo");
  sig_type_fspo = new SigType_fspo(sig_type_id_fspo, "fspo");
  sig_type_ao = new SigType_ao(sig_type_id_ao, "ao");
  sig_type_aod = new SigType_aod(sig_type_id_aod, "aod");
  sig_type_send = new SigType_send(sig_type_id_send, "send");
  sig_type_allocate = new SigType_allocate(sig_type_id_allocate,
                                           "allocate");
  sig_type_oid = new SigType_oid(sig_type_id_oid, "oid");
  sig_type_del = new SigType_del(sig_type_id_del, "del");
  sig_type_ter = new SigType_ter(sig_type_id_ter, "ter");
  sig_type_err = new SigType_err(sig_type_id_err, "err");
  sig_type_stresp = new SigType_stresp(sig_type_id_stresp, "stresp");
  sig_type_tcp_packet = new SigType_tcp_packet(sig_type_id_tcp_packet,
                                               "tcp_packet");
  sig_type_ip_packet = new SigType_ip_packet(sig_type_id_ip_packet,
                                             "ip_packet");

  /****************************************************************************
   * Statische Initialisierungsfunktionen der Bloecke aufrufen:
   ***************************************************************************/

  result = result & blk_application::Initialize();
  result = result & blk_tcp::Initialize();
  result = result & blk_ip::Initialize();
  result = result & blk_medium::Initialize();

  if (!result)
  {
    std::cerr << std::endl << "System initialization failed!" <<
                 std::endl;
    SCScheduler::Stop();
  }

  /****************************************************************************
   * System in SCSystem eintragen:
   ***************************************************************************/

  SCSystem::SetSystem(new sys_qtcp);

  return result;
}


/******************************************************************************
 * Beendigungsfunktion der SDL-Systemklasse (statisch)
 *****************************************************************************/

void sys_qtcp::Finish(void)
{
  /****************************************************************************
   * Signaltypen der SDL-Signale auf Blockebene zerstoeren:
   ***************************************************************************/

  delete sig_type_status;
  delete sig_type_close;
  delete sig_type_abort;
  delete sig_type_os;
  delete sig_type_of;
  delete sig_type_process_terminated;
  delete sig_type_closing;
  delete sig_type_upo;
  delete sig_type_fspo;
  delete sig_type_ao;
  delete sig_type_aod;
  delete sig_type_send;
  delete sig_type_allocate;
  delete sig_type_oid;
  delete sig_type_del;
  delete sig_type_ter;
  delete sig_type_err;
  delete sig_type_stresp;
  delete sig_type_tcp_packet;
  delete sig_type_ip_packet;

  /****************************************************************************
   * Statische Beendigungsfunktionen der Bloecke aufrufen:
   ***************************************************************************/

  blk_application::Finish();
  blk_tcp::Finish();
  blk_ip::Finish();
  blk_medium::Finish();

  /****************************************************************************
   * System in SCSystem austragen:
   ***************************************************************************/

  delete SCSystem::GetSystem();
}

/******************************************************************************
 * Konstruktor
 *****************************************************************************/

sys_qtcp::sys_qtcp(void)
{
}

/******************************************************************************
 * Destruktor
 *****************************************************************************/

sys_qtcp::~sys_qtcp(void)
{
}

/******************************************************************************
 * Save-Methode zur Sicherung der System-Sensoren
 *****************************************************************************/

SCBoolean sys_qtcp::SystemSave(SCMem &save_area)
{

  return true;
}

/******************************************************************************
 * Restore-Methode zur Restaurierung der System-Sensoren
 *****************************************************************************/

SCBoolean sys_qtcp::SystemRestore(SCMem &save_area)
{

  return true;
}

/******************************************************************************
 * Size-Methode liefert benoetigten Speicherplatz fuer die Sensoren
 *****************************************************************************/

void sys_qtcp::SystemSize(SCSize *cur_size)
{
}

